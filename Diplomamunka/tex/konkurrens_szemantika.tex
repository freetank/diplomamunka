\section{Erlang nyelv konkurrens résznyelvének szemantikája K keretrendszerben}
A K keretrendszernek erős kifejező ereje van, ami megkönnyíti a szemantikadefiníció megadását, még ilyen bonyolult témában is, ahol különböző folyamatok kommunikálnak egymással. A konkurrens résznyelv szemantikájának leírását nem kellett a nulláról kezdeni, már meg volt egy mag, amire lehetett építeni.

\subsection{Meglévő szemantikadefiníciók}
Az első lépés 3.6-os verzióról 4.0-ra való áttérés, és a modularizálás volt.

\paragraph{tokens.k}
Ebben a fájlban van az Erlang specifikus literáloknak és a változóknak a szintaxisa, mely két modult tartalmaz.

\input{tex/Szabalyok/41TOKENS-PARSING}

A \textit{TOKENS-PARSING}, ahogy látható felül, az \textit{UnquotedAtom}, \textit{Atom}, \textit{Joker} és a \textit{Variable} fajtákat tartalmazza. A definíciók maguktól értetendőek. A \textit{Bool} és az UnquotedAtom alfajtája az Atomnak, viszont az aposztrófok közé írt atom nem, mivel egyelőre nincs definiálva. A Joker és a Variable definíciója ebben a modulban nem látható. Ennek az az oka, hogy a K keretrendszer rendelkezik egy \textit{\#KVariable} fajtával, amelynek a definíciójában megadott reguláris kifejezés által meghatározott lehetséges karakterláncok halmaza és a hasonló módon Variable által meghatározott halmaz metszete nem üres, emiatt ha itt definiálnánk, parszolási hibát kapnánk.
\newline
\input{tex/Szabalyok/41TOKENS-SYNTAX}

A TOKENS-SYNTAX modulban megadva a definíciókat ezt a hibát elkerülhetjük. Ilyenkor a parszolás után kapott fán lévő levelek \#KVariable címkéit lecseréli a saját Variable fajtával.

\paragraph{exp-shared.k}
Az \textit{EXP-SHARED} modul az \textit{EXP} modulból -- később kerül ismertetésre -- leválasztott egység.

\input{tex/Szabalyok/41EXP-SHARED}

Az \textit{Exp} -- a kifejezések fajtája -- deklarálása itt található. Szinte az összes modul használja az Exp és az Exps fajtákat, viszont vannak olyanok, ahol szükségtelen az egész Exp-hez tartozó szintaxist importálni. Ha a modulokban újra lenne deklarálva, az névütközéshez vezetne. Az EXP-SHARED modul ezt hivatott elkerülni.

Ezenfelül még definiálva lett az \textit{Exps} fajta, ami vesszővel elválasztott Exp-ek sorozata a strict attribútummal, mely a kötelező kiértékelést jelöli, sorrendet figyelmen kívül hagyva. A \textit{Match0} a case és az if kifejezések által is használt részkifejezések, amely a mintát és az utána lévő kifejezést tartalmazza, a \textit{Match} pedig ezek pontosvesszővel elválasztott sorozata. Fontos megjegyezni, hogy ezek a részkifejezések kiértékelése sorban történik. Vagyis mindig csak a mintaillesztés során a nyíl előtti rész, majd egyezés esetén pedig annak az "ágnak" a kifejezése értékelődik ki.

\paragraph{operators.k}
Az \textit{OPERATORS-PARSING} modulban bővítjük a kifejezések szintaxisát aritmetikai, összehasonlító és logikai operátorokkal.

\input{tex/Szabalyok/41OPERATORS-PARSING}

Az \textit{OPERATORS} modulban pedig az ezekhez tartozó szemantikadefiníciók találhatóak. Mivel a szintaxis esetén megadtuk minden egyes operátornál a strict attribútumot, ezért a szabály alkalmazása várat magára egészen addig, amíg az operandusokat ki nem értékelte.

\input{tex/Szabalyok/41ARITHMETICS-EXAMPLE}

Ahogy a példában látható, az aritmetikai operátorok szemantikájának definiálása esetén nagy segítséget jelent a K keretrendszer beépített operátorai.

\paragraph{tuple.k}
Ebben a fájlban a tuple típussal kapcsolatos szintaxis és szemantika található. A \textit{TUPLE-PARSING} modul bővíti az Exp fajtát a tuple szintaxisával.

\input{tex/Szabalyok/41TUPLE-PARSING}

A \textit{TUPLE} modul az OPERATORS modul kibővítése tuple specifikus összehasonlító operátorokkal.

\input{tex/Szabalyok/41TUPLE-EXAMPLE}

Egy strukturális átalakítás látható, ami jó példa arra, hogyan lehet felhasználni, a már meglévő szemantikadefinícióinkat újabbak definiálására.

\paragraph{list.k}

Az \textit{ERL-LIST-PARSING} modulban az erlangban használatos lista két fajta szintaxisa található.

\input{tex/Szabalyok/41ERL-LIST-PARSING}

Az \textit{ERL-LIST} modul csak átalakítási szabályokat tartalmaz melyet a \textit{macro} attribútum jelöl. Ezeket a keretrendszer a legelső számítási lépés előtt elvégzi.

\input{tex/Szabalyok/41ERL-LIST-EXAMPLE}

\paragraph{errors.k}

Az \textit{ERRORS} modul a futásidejű hibák fajtáit tartalmazza.

\input{tex/Szabalyok/41ERRORS}

\paragraph{value.k}

Előző modulokban látható, hogy szintaxis esetén egyes fajtákhoz strict attribútum van rendelve. Ennek a következménye, hogy a szemantikai szabályok esetén, csakis akkor illeszkedik egy minta, ha a keretrendszer a szabály előfeltételében szereplő összes fajtát a K specifikus \textit{KResult} fajtára átalakította. A \textit{VALUE} modulban ezeket gyűjtöttük össze a \textit{Value} fajtába.

\input{tex/Szabalyok/41VALUE}

\paragraph{exp.k}

Az \textit{EXP-PARSING} modul tartalmazza azon kifejezések szintaxisát, melyekhez lett szemantika definiálva.

\input{tex/Szabalyok/41EXP-PARSING}

Az \textit{EXP} modul pedig az ezekhez tartozó szemantikadefiníciókat tartalmazza.

\input{tex/Szabalyok/41EXP-EXAMPLE}

A kiemelt példában érdemes megfigyelni, ahogy a case szabálya környezetet vált. A régi környezetet, amit a \textit{Rho} nevű változó jelöl, átemeli a kiértékelési folyamba. Mikor a case kifejezés visszatérési értékét megkapjuk, akkor ugyan ebből a folyamból visszaolvassa a régi környezetet.

%TODO Eddig okés
\paragraph{erl-parsing.k}

Az ERL-PARSING modul egyesíti az összes -PARSING végű modult.

*Kép*

Ezenfelül meghatározza a különböző kifejezések közötti prioritásokat is. Jelenleg az Erlang modul rendszer szintaxisa még nincs kidolgozva, így egy fájl felépítése két nagy részből áll: a függvénydefiníciós rész és a program rész, amit --- jel választ el egymástól.

\paragraph{erl.k}

Az \textit{ERL} modul három dologért felelős.

*Kép*

Először is a Value alfajtája lesz a \textit{KResult} K specifikus szintaktikus fajtának.

*Kép*

Másodszor a program fájl feldolgozását definiálja. Az elején a függvénydefiníciós részt a későbbi függvény hívások miatt a \textit{defs} állapotba elmenti.

*Kép*

Harmadszorra pedig az általunk definiált függvények hívásának szemantikáját definiálja. Itt a megszokott módon környezetet vált, és a defs állapotban megkeresi a hozzá tartozó függvénydefiníciót.

% Eddig ellenorizve

\paragraph{config.k}

Ebben a fájlban a kezdő konfiguráció található.

*Regi kep store nelkul*

A fenti kezdő konfiguráció ezen diplomamunka előtti állapotot mutatja. A \textit{k} cella tartalmazza az adott konfigurációban a hátralévő programot. Az állapot jelenleg két függvényből áll. 

defs: Atom -> Lista ahol Lista {f | f : Exps -> Body}

Ahogy feljebb olvasható a \textit{defs} tartalmazza a függvénydefiníciókat. A függvény nevéhez hozzárendeli a lehetséges függvénydefiníciókat.

env: Variable -> Value

Az \textit{env} függvény pedig a változó nevéhez hozzárendeli a változóhoz kötött értéket.

%TODO először ezeket
%	függvény definiálás az Erlang bemutatásánál
%	Rendes matekos jelölésekkel a függvényeket (kérdés hogy a generáláskor pontosan mit kapok, bár nem tűnik ellentmondásosnak vele
%	Ucsó paragraph szebben fogalmazni, helyesírás stb

%TODO
%	Meglévő szemantikadefiníciók
%	ha kell külön subsection az erlang folyamatokról
%	szemantika definíció kidejtése, plusz mindegyiknél mit jelent a kifejezés
%	milyen tesztek voltak hogy működik mennyire segített, honnan veszem, hogy azok helyesek?
\subsection{Erlang folyamatok}