\section{Erlang nyelv konkurrens résznyelvének szemantikája K keretrendszerben}
A diplomamunka lényegi része az Erlang nyelv konkurrens résznyelvének szemantikájának definiálása volt. A K keretrendszernek erős kifejező ereje, megkönnyítette a szemantikadefiníció megadását, még ilyen bonyolult témában is, ahol különböző folyamatok kommunikálnak egymással. A konkurrens résznyelv szemantikájának leírását nem kellett a nulláról kezdeni, már meg volt egy mag, amire lehetett építeni. Ez a mag főleg az egyszerűbb kifejezéseket, függvénydefiniálások és - hívások szemantikáját tartalmazta. Az Erlang folyamatok ismertetése után megláthatjuk, hogyan épült fel erre az alapra a konkurrens résznyelv szemantikája.

\subsection{Meglévő szemantikadefiníciók}
Az első lépés a meglévő szemantikadefiníciók 3.6-os verzióról 4.0-ra való átírása, és ezek modularizálása.

\paragraph{tokens.k}
Ebben a fájlban van az Erlang specifikus literáloknak és a változóknak a szintaxisa, mely két modult tartalmaz.

\input{tex/Szabalyok/41TOKENS-PARSING}

A \textit{TOKENS-PARSING}, ahogy látható felül, az \textit{UnquotedAtom}, \textit{Atom}, \textit{Joker} és a \textit{Variable} fajtákat tartalmazza. A definíciók maguktól értetendőek. A \textit{Bool} és az UnquotedAtom alfajtája az Atomnak, viszont az aposztrófok közé írt atom nem, mivel egyelőre nincs definiálva. A Joker és a Variable definíciója ebben a modulban nem látható. Ennek az az oka, hogy a K keretrendszer rendelkezik egy \textit{\#KVariable} fajtával, amelynek a definíciójában megadott reguláris kifejezés által meghatározott lehetséges karakterláncok halmaza és a hasonló módon Variable által meghatározott halmaz metszete nem üres, emiatt ha itt definiálnánk, parszolási hibát kapnánk.
\newline
\input{tex/Szabalyok/41TOKENS-SYNTAX}

A TOKENS-SYNTAX modulban megadva a definíciókat ezt a hibát elkerülhetjük. Ilyenkor a parszolás után kapott fán lévő levelek \#KVariable címkéit lecseréli a saját Variable fajtával.

\paragraph{exp-shared.k}
Az \textit{EXP-SHARED} modul az \textit{EXP} modulból -- később kerül ismertetésre -- leválasztott egység.

\input{\RULESFOLDER/41EXP-SHARED}

Az \textit{Exp} -- a kifejezések fajtája -- deklarálása itt található. Szinte az összes modul használja az Exp és az Exps fajtákat, viszont vannak olyanok, ahol szükségtelen az egész Exp-hez tartozó szintaxist importálni. Ha a modulokban újra lenne deklarálva, az névütközéshez vezetne. Az EXP-SHARED modul ezt hivatott elkerülni.

Ezenfelül még definiálva lett az \textit{Exps} fajta, ami vesszővel elválasztott Exp-ek sorozata a strict attribútummal, mely a kötelező kiértékelést jelöli, sorrendet figyelmen kívül hagyva. A \textit{Match0} a case és az if kifejezések által is használt részkifejezések, amely a mintát és az utána lévő kifejezést tartalmazza, a \textit{Match} pedig ezek pontosvesszővel elválasztott sorozata. Fontos megjegyezni, hogy ezek a részkifejezések kiértékelése sorban történik. Vagyis mindig csak a mintaillesztés során a nyíl előtti rész, majd egyezés esetén pedig annak az "ágnak" a kifejezése értékelődik ki.

\paragraph{operators.k}
Az \textit{OPERATORS-PARSING} modulban bővítjük a kifejezések szintaxisát aritmetikai, összehasonlító és logikai operátorokkal.

\input{\RULESFOLDER/41OPERATORS-PARSING}

Az \textit{OPERATORS} modulban pedig az ezekhez tartozó szemantikadefiníciók találhatóak. Mivel a szintaxis esetén megadtuk minden egyes operátornál a strict attribútumot, ezért a szabály alkalmazása várat magára egészen addig, amíg az operandusokat ki nem értékelte.

\input{\RULESFOLDER/41ARITHMETICS-EXAMPLE}

Ahogy a példában látható, az aritmetikai operátorok szemantikájának definiálása esetén nagy segítséget jelent a K keretrendszer beépített operátorai.

\paragraph{tuple.k}
Ebben a fájlban a tuple típussal kapcsolatos szintaxis és szemantika található. A \textit{TUPLE-PARSING} modul bővíti az Exp fajtát a tuple szintaxisával.

\input{\RULESFOLDER/41TUPLE-PARSING}

A \textit{TUPLE} modul az OPERATORS modul kibővítése tuple specifikus összehasonlító operátorokkal.

\input{\RULESFOLDER/41TUPLE-EXAMPLE}

Egy strukturális átalakítás látható, ami jó példa arra, hogyan lehet felhasználni, a már meglévő szemantikadefinícióinkat újabbak definiálására.

\paragraph{list.k}

Az \textit{ERL-LIST-PARSING} modulban az erlangban használatos lista két fajta szintaxisa található.

\input{\RULESFOLDER/41ERL-LIST-PARSING}

Az \textit{ERL-LIST} modul csak átalakítási szabályokat tartalmaz melyet a \textit{macro} attribútum jelöl. Ezeket a keretrendszer a legelső számítási lépés előtt elvégzi.

\input{\RULESFOLDER/41ERL-LIST-EXAMPLE}

\paragraph{errors.k}

Az \textit{ERRORS} modul a futásidejű hibák fajtáit tartalmazza.

\input{\RULESFOLDER/41ERRORS}

\paragraph{value.k}

Előző modulokban látható, hogy szintaxis esetén egyes fajtákhoz strict attribútum van rendelve. Ennek a következménye, hogy a szemantikai szabályok esetén, csakis akkor illeszkedik egy minta, ha a keretrendszer a szabály előfeltételében szereplő összes fajtát a K specifikus \textit{KResult} fajtára átalakította. A \textit{VALUE} modulban ezeket gyűjtöttük össze a \textit{Value} fajtába.

\input{\RULESFOLDER/41VALUE}

\paragraph{exp.k}

Az \textit{EXP-PARSING} modul tartalmazza azon kifejezések szintaxisát, melyekhez lett szemantika definiálva.

\input{\RULESFOLDER/41EXP-PARSING}

Az \textit{EXP} modul pedig az ezekhez tartozó szemantikadefiníciókat tartalmazza.

\input{\RULESFOLDER/41EXP-EXAMPLE}

A kiemelt példában érdemes megfigyelni, ahogy a case szabálya környezetet vált. A régi környezetet, amit a \textit{Rho} nevű változó jelöl, átemeli a kiértékelési folyamba. Mikor a case kifejezés visszatérési értékét megkapjuk, akkor ugyan ebből a folyamból visszaolvassa a régi környezetet.

\paragraph{erl-parsing.k}

Az ERL-PARSING modul egyesíti az összes -PARSING végű modult.

\input{\RULESFOLDER/41ERL-PARSING}

Ezenfelül meghatározza a különböző kifejezések közötti prioritásokat is. Jelenleg az Erlang modul rendszer szintaxisa még nincs kidolgozva. Egy fájl felépítése két nagy részből áll: a függvénydefiníciós rész és a program rész, amit $---$ jel választ el egymástól.

\paragraph{erl.k}

Az \textit{ERL} modul három dologért felelős.

\input{\RULESFOLDER/41ERL-EXAMPLE-KRESULT}

Először is a Value alfajtája lesz a \textit{KResult} K specifikus fajtának.

\input{\RULESFOLDER/41ERL-EXAMPLE-PREPROCESSING}

Másodszor a program fájl feldolgozását definiálja. A függvénydefiníciós részt a későbbi függvény hívások miatt a \textit{defs} állapotba elmenti.

\input{\RULESFOLDER/41ERL-EXAMPLE-FUNCALL}

Harmadszorra pedig az általunk definiált függvények hívásának szemantikáját definiálja. Itt a megszokott módon környezetet vált, és a defs állapotban megkeresi a hozzá tartozó függvénydefiníciót.

\paragraph{config.k}

Ebben a fájlban a kezdő konfiguráció található.

\input{\RULESFOLDER/41CONFIG}

A fenti kezdő konfiguráció ezen diplomamunka előtti állapotot mutatja. A \textit{k} cella tartalmazza az adott konfigurációban a hátralévő programot. Az állapot jelenleg két parciális függvényből áll. 

\begin{align*}
defs: Atom \rightarrow Lista \quad \textrm{ahol} \quad Lista \subseteq \{f | f : Exps \rightarrow Exp\}
\end{align*}

Ahogy feljebb olvasható a \textit{defs} tartalmazza a függvénydefiníciókat: a függvény nevéhez hozzárendeli a lehetséges függvénytörzseket. Itt a \textit{Lista} alatt a K keretrendszer beépített listája értendő.

\begin{align*}
env: Variable \rightarrow Value
\end{align*}

Az \textit{env} függvény pedig a változó nevéhez hozzárendeli a változóhoz kötött értéket.

Ebben az alfejezetben egy rövid és tömör áttekintést kaphattunk a már meglévő szemantikadefiníciókról. Mielőtt tovább haladnánk, hogy megismerjük a konkurrens résznyelvhez tartozó szemantikadefiníciókat, érdemes egy rövid betekintést nyerni az erlang nyelv folyamatainak világába.

\subsection{Erlang folyamatok}
Az Erlang nyelv fő erőssége a konkurrens és az elosztott programozásban rejlik. Konkurrencia alatt a különböző szálak egy idejű kezelését értjük. Ez természetesen lehet valós párhuzamos megvalósítású több magos gépek esetén, illetve főként egy magos környezetben a szálak folyamatos cserélgetésével, így a párhuzamosság látszatát kapjuk. Ilyen szálakat Erlang nyelven könnyedén létrehozhatunk és eszközt is ad az egymás közötti kommunikációra. Erlangban ezeket a szálakat folyamatoknak hívjuk. Ez logikus megnevezés mivel a folyamatok egymással nem osztanak meg közvetlenül adatot. Az információcsere folyamatok között üzenetküldéssel történik.

Egy ilyen folyamatot a \textit{spawn(Modul, Exportált\_Függvény, ArgumentLista)} hívással tudunk létrehozni.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn.erl}

A \textit{representSpawn} modul egy egyszerű példát mutat a spawn használatára. A \textit{start} függvénye három darab folyamatot indít el egymás után, ami függetlenül fog futni a létrehozó folyamattól. Ha meghívjuk a start függvényt az egyik lehetséges eredmény az alábbi lehet.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn_start.erl}

Látható hogy a kiírás sorrendje ebben az esetben 8, 10, 9. Ezen a sorozaton jól látható, hogy a folyamatok egymástól függetlenül futnak, mivel a processzor úgy ütemezett, hogy a 4-es argumentummal meghívott folyamat írja ki az eredményét a legkésőbb. A zárójelben ponttal elválasztott számok a folyamatazonosító. Minden folyamathoz tartozik egy ilyen egyedi azonosító, ami a spawn függvény visszatérési értéke.

Mivel a folyamatok nem osztják meg közvetlenül saját adataikat, az egymással való kommunikáció üzenetküldéssel folyik. Ezt legegyszerűbben a klasszikus ping-pong példán lehet bemutatni \cite{RefMan}.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong.erl}

A példában két folyamat kommunikál egymással. Az üzenet, akár egy ping pong labda, halad az egyik folyamattól a másik folyamatig. A \textit{start} függvény hozza létre a két folyamatot, amelyek kommunikálnak egymással. Az első folyamat, amit létrehoz, a \textit{pong} függvényt hívja meg, és eltárolja a folyamatazonosítóját egy változóba.

A pong függvény egy \textit{receive} kifejezést tartalmaz. Ez a szerkezet felelős az üzenetek fogadásáért. Minden folyamathoz tartozik egy postaláda, amibe az üzenetek érkeznek. Ezeken a receive minden ágára, kezdve az elsővel, mintaillesztést végez a beérkezésük sorrendjében, amíg egyezést nem talál. Ha sikeres volt a mintaillesztés, akkor azt az üzenetet eldobja a postaládából, és az adott ághoz tartozó kifejezést kiértékeli. Ha nem volt egyezés, vár amíg újabb üzenet nem jön, és újra a legrégebbi üzenettől elkezdi a mintaillesztést. Jelen esetben nagy valószínűséggel a pong folyamat postaládája üres, ezért üzenetfogadására vár.

A start létrehozza a második folyamatot, ami a \textit{ping} függvényt hívja meg két paraméterrel, egy számmal és egy folyamatazonosítóval. Az első paraméter megadja, hogy az üzenet küldés hányszor menjen végbe oda-vissza, a második paraméter pedig egy folyamatazonosító, amely folyamattal kommunikálni fog. A ping függvényben az első kifejezés a ! operátor. A két aritású operátorban az első operandusban megadott folyamatazonosító által meghatározott folyamatnak elküld egy a második operandusban megadott üzenetet. Itt az üzenet egy tuple, ami egy atomot és a \textit{self} függvényt tartalmazza. A self visszaadja az adott folyamat folyamatazonosítóját.

Ezalatt a másik várakozó folyamat üzenetet kapott a ping függvényt kiértékelő folyamattól. A második ágra illeszkedik az üzenet így kiírja hogy megérkezett, és nyomban válaszol is rá a ! operátorral. A válasz már csak egy atom, mivel a ping függvényt kiértékelő folyamat paraméterként megkapta a folyamatazonosítót. Ezután rekurzívan meghívja önmagát. Ekkor a ping vagy épp most kezdi el a receive kiértékelését, vagy már el is végzett egy mintaillesztést, és egy új üzenetre vár. A kapott üzenet illeszkedik a pong atomra így jelzi, hogy az üzenet megérkezett, és a függvény szintén rekurzívan meghívja önmagát, ám az üzenetküldés számát meghatározó paraméter értékét csökkenti eggyel. Ez egészen addig megy így, amíg ez az érték nulla nem lesz. Ekkor a ping másik paraméterezésére fognak illeszkedni a függvényhívásban megadott paraméterek. A finished atomot tartalmazó üzenetet küldi el, ami jelzi a pongnak, hogy az üzenet küldések folyamatának vége. Mind a két függvény kiírja, hogy befejeződött az üzenetküldés, és már nincs rekurzív hívás, így a függvények kiértékelődtek, a két folyamat terminál.

Lefuttatva a példa programot, feltételezve hogy a konzolra való kiíratást egyből végrehajtja, az alábbi eredményt kapjuk.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong_start.erl}

Ezzel az áttekintővel egy kép kialakult a folyamatok működéséről és kommunikációjáról, ami minimálisan szükséges a konkurrens szemantikadefiníciók könnyebb megértéséhez. A diplomamunka nem tér ki a több gépet tartalmazó elosztott programozásra.

\subsection{Konkurrens résznyelv szemantikája}

Szemantikadefiniálás gyakorlatilag a manuál értelmezéséből áll, amiből aztán megfelelő módszerrel, technikával formális szemantikadefiníciót készítünk. Ebben az alfejezetben kitérünk mit ír minden egyes nyelvi elemnél, milyen kikötések, kivételek vannak, és ezek alapján hogyan jutottunk el a végleges formális definícióig. A konfiguráció is bővült.


\input{\RULESFOLDER/43CONFIG}

ahol a process

\input{\RULESFOLDER/43CONFIG_PROCESS}

A kezdő konfiguráció kiegészült pár állapottal. Ezek leírása és tartalma azoknál a definícióknál lesz kifejtve, ahol először megjelennek. A résznyelv egész szemantikadefiníciója megtekinthető a diplomamunka mellékletében.%TODO tényleg?

% Eddig ellenorizve

%TODO
%	Process Creation
%		spawn
%		self
%	Registered Processes
%		register
%		registered
%		whereis
%		unregister
%	Message sending
%		operator !
%		receive, itt térjek ki az időre, várakoztatás stb
%	Links
%		link
%		spawn_link
%		unlink
%	Process Termination
%		process_flag(trap_exit, true)pipa
%		exit
%		exit(Pid,Reason)


%TODO
%	szemantika definíció kifejtése, plusz mindegyiknél mit jelent a kifejezés
%	milyen tesztek voltak hogy működik mennyire segített, honnan veszem, hogy azok helyesek?