\section{Erlang nyelv konkurrens résznyelvének szemantikája K keretrendszerben}
A diplomamunka lényegi része az Erlang nyelv konkurrens résznyelvének szemantikájának definiálása volt. A K keretrendszernek erős kifejező ereje, megkönnyítette a szemantikadefiníció megadását, még ilyen bonyolult témában is, ahol különböző folyamatok kommunikálnak egymással. A konkurrens résznyelv szemantikájának leírását nem kellett a nulláról kezdeni, már meg volt egy mag, amire lehetett építeni. Ez a mag főleg az egyszerűbb kifejezéseket, függvénydefiniálások és - hívások szemantikáját tartalmazta. Az Erlang folyamatok ismertetése után megláthatjuk, hogyan épült fel erre az alapra a konkurrens résznyelv szemantikája.

\subsection{Meglévő szemantikadefiníciók}
Az első lépés a meglévő szemantikadefiníciók 3.6-os verzióról 4.0-ra való átírása, és ezek modularizálása.

\paragraph{tokens.k}
Ebben a fájlban van az Erlang specifikus literáloknak és a változóknak a szintaxisa, mely két modult tartalmaz.

\input{tex/Szabalyok/41TOKENS-PARSING}

A \textit{TOKENS-PARSING}, ahogy látható felül, az \textit{UnquotedAtom}, \textit{Atom}, \textit{Joker} és a \textit{Variable} fajtákat tartalmazza. A definíciók maguktól értetendőek. A \textit{Bool} és az UnquotedAtom alfajtája az Atomnak, viszont az aposztrófok közé írt atom nem, mivel egyelőre nincs definiálva. A Joker és a Variable definíciója ebben a modulban nem látható. Ennek az az oka, hogy a K keretrendszer rendelkezik egy \textit{\#KVariable} fajtával, amelynek a definíciójában megadott reguláris kifejezés által meghatározott lehetséges karakterláncok halmaza és a hasonló módon Variable által meghatározott halmaz metszete nem üres, emiatt ha itt definiálnánk, parszolási hibát kapnánk.
\newline
\input{tex/Szabalyok/41TOKENS-SYNTAX}

A TOKENS-SYNTAX modulban megadva a definíciókat ezt a hibát elkerülhetjük. Ilyenkor a parszolás után kapott fán lévő levelek \#KVariable címkéit lecseréli a saját Variable fajtával.

\paragraph{exp-shared.k}
Az \textit{EXP-SHARED} modul az \textit{EXP} modulból -- később kerül ismertetésre -- leválasztott egység.

\input{\RULESFOLDER/41EXP-SHARED}

Az \textit{Exp} -- a kifejezések fajtája -- deklarálása itt található. Szinte az összes modul használja az Exp és az Exps fajtákat, viszont vannak olyanok, ahol szükségtelen az egész Exp-hez tartozó szintaxist importálni. Ha a modulokban újra lenne deklarálva, az névütközéshez vezetne. Az EXP-SHARED modul ezt hivatott elkerülni.

Ezenfelül még definiálva lett az \textit{Exps} fajta, ami vesszővel elválasztott Exp-ek sorozata a strict attribútummal, mely a kötelező kiértékelést jelöli, sorrendet figyelmen kívül hagyva. A \textit{Match0} a case és az if kifejezések által is használt részkifejezések, amely a mintát és az utána lévő kifejezést tartalmazza, a \textit{Match} pedig ezek pontosvesszővel elválasztott sorozata. Fontos megjegyezni, hogy ezek a részkifejezések kiértékelése sorban történik. Vagyis mindig csak a mintaillesztés során a nyíl előtti rész, majd egyezés esetén pedig annak az "ágnak" a kifejezése értékelődik ki.

\paragraph{operators.k}
Az \textit{OPERATORS-PARSING} modulban bővítjük a kifejezések szintaxisát aritmetikai, összehasonlító és logikai operátorokkal.

\input{\RULESFOLDER/41OPERATORS-PARSING}

Az \textit{OPERATORS} modulban pedig az ezekhez tartozó szemantikadefiníciók találhatóak. Mivel a szintaxis esetén megadtuk minden egyes operátornál a strict attribútumot, ezért a szabály alkalmazása várat magára egészen addig, amíg az operandusokat ki nem értékelte.

\input{\RULESFOLDER/41ARITHMETICS-EXAMPLE}

Ahogy a példában látható, az aritmetikai operátorok szemantikájának definiálása esetén nagy segítséget jelent a K keretrendszer beépített operátorai.

\paragraph{tuple.k}
Ebben a fájlban a tuple típussal kapcsolatos szintaxis és szemantika található. A \textit{TUPLE-PARSING} modul bővíti az Exp fajtát a tuple szintaxisával.

\input{\RULESFOLDER/41TUPLE-PARSING}

A \textit{TUPLE} modul az OPERATORS modul kibővítése tuple specifikus összehasonlító operátorokkal.

\input{\RULESFOLDER/41TUPLE-EXAMPLE}

Egy strukturális átalakítás látható, ami jó példa arra, hogyan lehet felhasználni, a már meglévő szemantikadefinícióinkat újabbak definiálására.

\paragraph{list.k}

Az \textit{ERL-LIST-PARSING} modulban az erlangban használatos lista két fajta szintaxisa található.

\input{\RULESFOLDER/41ERL-LIST-PARSING}

Az \textit{ERL-LIST} modul csak átalakítási szabályokat tartalmaz melyet a \textit{macro} attribútum jelöl. Ezeket a keretrendszer a legelső számítási lépés előtt elvégzi.

\input{\RULESFOLDER/41ERL-LIST-EXAMPLE}

\paragraph{errors.k}

Az \textit{ERRORS} modul a futásidejű hibák fajtáit tartalmazza.

\input{\RULESFOLDER/41ERRORS}

\paragraph{value.k}

Előző modulokban látható, hogy szintaxis esetén egyes fajtákhoz strict attribútum van rendelve. Ennek a következménye, hogy a szemantikai szabályok esetén, csakis akkor illeszkedik egy minta, ha a keretrendszer a szabály előfeltételében szereplő összes fajtát a K specifikus \textit{KResult} fajtára átalakította. A \textit{VALUE} modulban ezeket gyűjtöttük össze a \textit{Value} fajtába.

\input{\RULESFOLDER/41VALUE}

\paragraph{exp.k}

Az \textit{EXP-PARSING} modul tartalmazza azon kifejezések szintaxisát, melyekhez lett szemantika definiálva.

\input{\RULESFOLDER/41EXP-PARSING}

Az \textit{EXP} modul pedig az ezekhez tartozó szemantikadefiníciókat tartalmazza.

\input{\RULESFOLDER/41EXP-EXAMPLE}

A kiemelt példában érdemes megfigyelni, ahogy a case szabálya környezetet vált. A régi környezetet, amit a \textit{Rho} nevű változó jelöl, átemeli a kiértékelési folyamba. Mikor a case kifejezés visszatérési értékét megkapjuk, akkor ugyan ebből a folyamból visszaolvassa a régi környezetet.

\paragraph{erl-parsing.k}

Az ERL-PARSING modul egyesíti az összes -PARSING végű modult.

\input{\RULESFOLDER/41ERL-PARSING}

Ezenfelül meghatározza a különböző kifejezések közötti prioritásokat is. Jelenleg az Erlang modul rendszer szintaxisa még nincs kidolgozva. Egy fájl felépítése két nagy részből áll: a függvénydefiníciós rész és a program rész, amit $---$ jel választ el egymástól.

\paragraph{erl.k}

Az \textit{ERL} modul három dologért felelős.

\input{\RULESFOLDER/41ERL-EXAMPLE-KRESULT}

Először is a Value alfajtája lesz a \textit{KResult} K specifikus fajtának.

\input{\RULESFOLDER/41ERL-EXAMPLE-PREPROCESSING}

Másodszor a program fájl feldolgozását definiálja. A függvénydefiníciós részt a későbbi függvény hívások miatt a \textit{defs} állapotba elmenti.

\input{\RULESFOLDER/41ERL-EXAMPLE-FUNCALL}

Harmadszorra pedig az általunk definiált függvények hívásának szemantikáját definiálja. Itt a megszokott módon környezetet vált, és a defs állapotban megkeresi a hozzá tartozó függvénydefiníciót.

\paragraph{config.k}

Ebben a fájlban a kezdő konfiguráció található.

\input{\RULESFOLDER/41CONFIG}

A fenti kezdő konfiguráció ezen diplomamunka előtti állapotot mutatja. A \textit{k} cella tartalmazza az adott konfigurációban a hátralévő programot. Az állapot jelenleg két parciális függvényből áll. 

\begin{align*}
defs: Atom \rightarrow Lista \quad \textrm{ahol} \quad Lista \subseteq \{f | f : Exps \rightarrow Exp\}
\end{align*}

Ahogy feljebb olvasható a \textit{defs} tartalmazza a függvénydefiníciókat: a függvény nevéhez hozzárendeli a lehetséges függvénytörzseket. Itt a \textit{Lista} alatt a K keretrendszer beépített listája értendő.

\begin{align*}
env: Variable \rightarrow Value
\end{align*}

Az \textit{env} függvény pedig a változó nevéhez hozzárendeli a változóhoz kötött értéket.

Ebben az alfejezetben egy rövid és tömör áttekintést kaphattunk a már meglévő szemantikadefiníciókról. Mielőtt tovább haladnánk, hogy megismerjük a konkurrens résznyelvhez tartozó szemantikadefiníciókat, érdemes egy rövid betekintést nyerni az erlang nyelv folyamatainak világába.

\subsection{Erlang folyamatok}
Az Erlang nyelv fő erőssége a konkurrens és az elosztott programozásban rejlik. Konkurrencia alatt a különböző szálak egy idejű kezelését értjük. Ez természetesen lehet valós párhuzamos megvalósítású több magos gépek esetén, illetve főként egy magos környezetben a szálak folyamatos cserélgetésével, így a párhuzamosság látszatát kapjuk. Ilyen szálakat Erlang nyelven könnyedén létrehozhatunk és eszközt is ad az egymás közötti kommunikációra. Erlangban ezeket a szálakat folyamatoknak hívjuk. Ez logikus megnevezés mivel a folyamatok egymással nem osztanak meg közvetlenül adatot. Az információcsere folyamatok között üzenetküldéssel történik.

Egy ilyen folyamatot a \textit{spawn(Modul, Exportált\_Függvény, ArgumentLista)} hívással tudunk létrehozni.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn.erl}

A \textit{representSpawn} modul egy egyszerű példát mutat a spawn használatára. A \textit{start} függvénye három darab folyamatot indít el egymás után, ami függetlenül fog futni a létrehozó folyamattól. Ha meghívjuk a start függvényt az egyik lehetséges eredmény az alábbi lehet.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn_start.erl}

Látható hogy a kiírás sorrendje ebben az esetben 8, 10, 9. Ezen a sorozaton jól látható, hogy a folyamatok egymástól függetlenül futnak, mivel a processzor úgy ütemezett, hogy a 4-es argumentummal meghívott folyamat írja ki az eredményét a legkésőbb. A zárójelben ponttal elválasztott számok a folyamatazonosító. Minden folyamathoz tartozik egy ilyen egyedi azonosító, ami a spawn függvény visszatérési értéke.

Mivel a folyamatok nem osztják meg közvetlenül saját adataikat, az egymással való kommunikáció üzenetküldéssel folyik. Ezt legegyszerűbben a klasszikus ping-pong példán lehet bemutatni \cite{RefMan}.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong.erl}

A példában két folyamat kommunikál egymással. Az üzenet, akár egy ping pong labda, halad az egyik folyamattól a másik folyamatig. A \textit{start} függvény hozza létre a két folyamatot, amelyek kommunikálnak egymással. Az első folyamat, amit létrehoz, a \textit{pong} függvényt hívja meg, és eltárolja a folyamatazonosítóját egy változóba.

A pong függvény egy \textit{receive} kifejezést tartalmaz. Ez a szerkezet felelős az üzenetek fogadásáért. Minden folyamathoz tartozik egy postaláda, amibe az üzenetek érkeznek. Ezeken a receive minden ágára, kezdve az elsővel, mintaillesztést végez a beérkezésük sorrendjében, amíg egyezést nem talál. Ha sikeres volt a mintaillesztés, akkor azt az üzenetet eldobja a postaládából, és az adott ághoz tartozó kifejezést kiértékeli. Ha nem volt egyezés, vár amíg újabb üzenet nem jön, és újra a legrégebbi üzenettől elkezdi a mintaillesztést. Jelen esetben nagy valószínűséggel a pong folyamat postaládája üres, ezért üzenetfogadására vár.

A start létrehozza a második folyamatot, ami a \textit{ping} függvényt hívja meg két paraméterrel, egy számmal és egy folyamatazonosítóval. Az első paraméter megadja, hogy az üzenet küldés hányszor menjen végbe oda-vissza, a második paraméter pedig egy folyamatazonosító, amely folyamattal kommunikálni fog. A ping függvényben az első kifejezés a ! operátor. A két aritású operátorban az első operandusban megadott folyamatazonosító által meghatározott folyamatnak elküld egy a második operandusban megadott üzenetet. Itt az üzenet egy tuple, ami egy atomot és a \textit{self} függvényt tartalmazza. A self visszaadja az adott folyamat folyamatazonosítóját.

Ezalatt a másik várakozó folyamat üzenetet kapott a ping függvényt kiértékelő folyamattól. A második ágra illeszkedik az üzenet így kiírja hogy megérkezett, és nyomban válaszol is rá a ! operátorral. A válasz már csak egy atom, mivel a ping függvényt kiértékelő folyamat paraméterként megkapta a folyamatazonosítót. Ezután rekurzívan meghívja önmagát. Ekkor a ping vagy épp most kezdi el a receive kiértékelését, vagy már el is végzett egy mintaillesztést, és egy új üzenetre vár. A kapott üzenet illeszkedik a pong atomra így jelzi, hogy az üzenet megérkezett, és a függvény szintén rekurzívan meghívja önmagát, ám az üzenetküldés számát meghatározó paraméter értékét csökkenti eggyel. Ez egészen addig megy így, amíg ez az érték nulla nem lesz. Ekkor a ping másik paraméterezésére fognak illeszkedni a függvényhívásban megadott paraméterek. A finished atomot tartalmazó üzenetet küldi el, ami jelzi a pongnak, hogy az üzenet küldések folyamatának vége. Mind a két függvény kiírja, hogy befejeződött az üzenetküldés, és már nincs rekurzív hívás, így a függvények kiértékelődtek, a két folyamat terminál.

Lefuttatva a példa programot, feltételezve hogy a konzolra való kiíratást egyből végrehajtja, az alábbi eredményt kapjuk.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong_start.erl}

Ezzel az áttekintővel egy kép kialakult a folyamatok működéséről és kommunikációjáról, ami minimálisan szükséges a konkurrens szemantikadefiníciók könnyebb megértéséhez. A diplomamunka nem tér ki a több gépet tartalmazó elosztott programozásra.

\subsection{Konkurrens résznyelv szemantikája}

Szemantikadefiniálás gyakorlatilag a manuál értelmezéséből áll, amiből aztán megfelelő módszerrel, technikával formális szemantikadefiníciót készítünk. Ebben az alfejezetben kitérünk mit ír minden egyes nyelvi elemnél, milyen kikötések, kivételek vannak, és ezek alapján hogyan jutottunk el a végleges formális definícióig. A konfiguráció is bővült.


\input{\RULESFOLDER/43CONFIG}

ahol a process

\input{\RULESFOLDER/43CONFIG_PROCESS}

A kezdő konfiguráció kiegészült pár állapottal. Ezek leírása és tartalma azoknál a definícióknál lesz kifejtve, ahol először megjelennek. A résznyelv egész szemantikadefiníciója megtekinthető a diplomamunka mellékletében.%TODO tényleg?

\subsubsection{Folyamat létrehozása}
A folyamatok létrehozásáról az előző alfejezetben már tettem említést, ami a spawn függvénnyel lehetséges. A konfigurációban a \textit{processes} állapot tartalmazza a folyamatokat, ami gyakorlatilag egy multihalmaz (a multihalmaz jellege sose lesz kihasználva, mivel a folyamatazonosító mindig egyedi minden folyamatnak, emiatt nem létezhet két azonos elem a multihalmazban). Minden sikeres spawn híváskor egy új \textit{process} elem kerül be a konfigurációba. Ez a process tartalmazza a már említett k cellát és az env állapotot.

A spawn függvénynek négy féle paraméterezése létezik. A három paraméterből álló szemantikadefiníciója lett megvalósítva. Az első paramétere a modul neve, amiben a függvény található. Mivel a modul rendszer szintaxisa és szemantikája még nem lett definiálva K keretrendszerben, emiatt az itt lévő atomot mindig figyelmen kívül hagyjuk. Második paramétere a függvény neve, harmadik pedig egy lista, ami a második paraméterben meghatározott függvény aktuális paramétereit tartalmazza. A konfiguráció átmenet létrehoz egy új process elemet, vagyis egy új folyamatot, a kezdőkonfiguráció szerinti állapot szerint. Egyedül a k cellát és a \textit{pid} állapotot módosítja. A k cellába a függvény hívás kerül a megadott paraméterekkel, amit a \textit{GetCommaSeparatedValuesFromList} szemantikus függvény a megfelelő alakra hoz, vagyis az átadott listából egy Values fajtára alakít. A pid állapot pedig egy egyedileg generált folyamatazonosítót fog tartalmazni, ami szintén bekerül \textit{processIds} állapot halmazába. A processIds a futó folyamatok folyamatazonosítóinak a listája. Egyelőre csak a helyes működés van definiálva, a függvény által dobott futásidejű hibák nincsenek. Ilyenek például, ha rossz függvény nevet, vagy aritású függvényt adunk meg.

\vfill %TODO Ha módosul a szöveg lehet nem kell

\input{\RULESFOLDER/43SELF}

A self függvény szemantikadefiníciója egy szabályból áll, ami fent látható. A self visszatérési értéke az éppen futó folyamat folyamatazonosítója. A szabály a saját process cellájában lévő pid állapotra illeszkedik, és ezt az egyedi azonosítót tartalmazza a k cella az átmenet után, amit a folyamat létrehozásakor generáltunk.

\subsubsection{Folyamatok azonosítása}

A folyamatokra a már előbb bemutatott folyamatazonosítóval is tudunk hivatkozni, ám nevesíthetjük is azokat, a két paraméteres \textit{register} függvénnyel. Az első paramétere az általunk választott név, ami egy atom, a második pedig a folyamatazonosító, amit ehhez a névhez szeretnénk társítani. Visszatérési értéke mindig true. \textit{badarg} futásidejű hibát okozhat az alábbi esetekben:

\begin{itemize}
\item ha az első argumentumban megadott névhez már lett folyamat rendelve
\item ha a második paraméterben megadott folyamatazonosító nem létezik
\item ha a második paraméterben megadott folyamatazonosítóhoz már rendeltünk nevet
\item ha az első paraméter az \textit{undefined} atom
\end{itemize}

A függvénnyel több gépet tartalmazó környezetben folyamatazonosító helyett portot is átadhatunk paraméternek. Ahogy már említettem, a szemantikadefiníció nem tér ki az ilyen esetekre.

Ehhez a szemantikadefinícióhoz három szabály is tartozik.

\input{\RULESFOLDER/43REGISTER}

Két szabály a sikeres név-folyamatazonosító hozzárendelése esetén, egy pedig a badarg futásidejű hiba esetén való átmenet. A fenti szabály a sikeres hozzárendelés nem saját folyamatazonosító esetén. Látható, hogy egy másik folyamat pid cellájára illeszkedik, amit a \textit{P} változóba ment el, és a hozzátársított névvel (\textit{Name}) a \textit{registeredProcesses} állapot map-ét bővíti az átmenet. Ez az állapot név-folyamatazonosító párokat tartalmaz, ami a nevekhez való társításokat tárolja. Az illeszkedés esetén való feltételt érdemes részletesebben megvizsgálni. Ez gyakorlatilag az előbb listaként felsorolt állítások tagadásai. Az \textit{RP}-ben lévő párok nem tartalmazhatják külön a regisztrált nevet, illetve a folyamatazonosítót, nem lehet a név undefined atom, és a folyamatazonosítónak benne kell lennie az Ids halmazban, ezzel kötjük ki, hogy csak futó folyamatokhoz tudunk nevet társítani.

A másik sikeres szabály hasonló az előzőhöz, azzal a kivétellel, hogy itt a folyamat a saját azonosítójához akar nevet társítani, így nem egy process cella pid állapotára illeszkedik, hanem a sajátjáéra. A badarg futásidejű hibát kiváltó szabály esetén a k cellában lévő átmenet ezt a hibát adja, a feltételek pedig az előző szabályokénak a negáltja.

Az így regisztrált nevek lekérhetőek a \textit{registered} paraméternélküli függvénnyel. A neveket egy listában adja vissza.

\input{\RULESFOLDER/43REGISTERED}

A fent látható szabály a registedProcesses állapotra illeszkedik, és az \textit{RP} változóba olvassa be a név-folyamatazonosító párokat. A \textit{fromSetToErlList} szemantikus függvény a paraméterként átadott neveket tartalmazó halmazból Erlang listát képez, ami az átmenet eredménye lesz a k cellában.

A \textit{whereis} függvény megadja a paraméterben átadott atomhoz tartozó folyamatazonosítót. Ha még nem volt hozzárendelés az undefined atommal tér vissza.

\input{\RULESFOLDER/43WHEREIS_UNDEFINED}

A szemantikadefiníció két szabályból áll. A fenti írja le a működést abban az esetben, ha az atomhoz nincs hozzárendelve folyamatazonosító. Az illeszkedéssel az \textit{RP} változóba beolvassa a regisztrált név-folyamatazonosító párokat, és ha a nevekből alkotott halmaz nem tartalmazza a \textit{Name} változóban lévő atomot, akkor a k cellában az átmenet az undefined atomot adja. A másik szabály találat esetén visszaadja a Name-hez rendelt folyamatazonosítót a mapből.

A register függvény segítségével létre hozott név-folyamatazonosító társítást törölhetjük az \textit{unregister} segítségével. Visszatérési értéke mindig \textit{true}. Ha a paraméterében átadott atomhoz nincs folyamatazonosító rendelve, akkor \textit{badarg} futásidejű hibát okoz.

\input{\RULESFOLDER/43UNREGISTER}

Itt is két szabályból áll a definíció. Ha már volt regisztrálva a \textit{Name} változóban lévő atom, akkor a fent látható szabály illeszkedik. Az \textit{undef} segítségével tudunk egy map-ben lévő kulcs értéket törölni a hozzárendelt értékeivel együtt. A második szabály átmenete természetesen a \textit{badarg} futásidejű hibához vezet.

% Eddig ellenorizve

\subsubsection{Üzenet küldés és fogadás}

Ahogy már korábban volt szó róla a folyamatok üzenetekkel tudnak egymással kommunikálni. Egy üzenetet a ! operátorral küldhetünk. Két operandusa olyan kifejezések lehetnek, ahol az elsőnek egy folyamatazonosítóra kell hogy kiértékelődjön, a második pedig az üzenet, amit el akarunk küldeni. Ha az első paraméter egy névre értékelődik ki, amihez nincs regisztrálva folyamatazonosító, akkor \textit{badarg} futásidejű hibát kapunk. Azonban akármilyen folyamatazonosítónak küldünk üzenetet, akár létezik az azonosított folyamat akár nem, az üzenet küldés soha sem okoz futásidejű hibát. Az operátor visszatérési érték a második kifejezés értéke lesz.

Ehhez már bonyolultabb szemantikadefiníció tartozik 6 szabállyal. Ezek közül ötöt ismertetek, majd a \textit{receive} ismertetése közben pedig a hatodikat is.

\input{\RULESFOLDER/43SENDTOOTHER}

Az üzenetküldéskor leggyakrabban használt eset szabálya látható felül. A \textit{P} változóban lévő folyamatazonosító által meghatározott folyamatnak küldi el a \textit{V} változóban lévő értéket. Az illeszkedés a \textit{P} szerinti változó alapján történik, így látható a második process cella. Itt az átmenet a mailbox állapot listájának a végére fűzi a \textit{V} üzenetet. A mailbox a folyamatokhoz tartozó postaláda állapota, a beérkező üzeneteket időrendben tároló lista. A feltétel második része érdekes csak most számunkra, ami azt mondja meg hogy az adott \textit{P} folyamat tényleg létezik-e. Hasonló a szabály akkor is, ha egy folyamat saját magának akar üzenetet küldeni. Ekkor a szabály a saját pid állapotára illeszkedik, és az átmenet a saját üzeneteinek a végéhez fűzi az üzenetet. A harmadik szabály feltétele azt mondja ki, hogy az adott \textit{P} folyamat nem létezik, így a k cella átmenete végbe megy, az üzenet lesz a cél, de semmi változás nem történik egyik folyamat postafiókjában sem.

\input{\RULESFOLDER/43SENDTOREGISTER}

%TODO
%	registeres üzenetküldés
%	ellenőrzés
%	receive...

%TODO
%	Message sending
%		operator !
%		receive, itt térjek ki az időre, várakoztatás stb
%	Links
%		link
%		spawn_link
%		unlink
%	Process Termination
%		process_flag(trap_exit, true)pipa
%		exit
%		exit(Pid,Reason)

%                      <processes color="orange">pipa
%                          <process multiplicity="*" color="magenta">pipa
%                              <k color="green"> $PGM:Pgm </k>pipa
%                              <env color="LightSkyBlue"> .Map </env>pipa
%                              <pid> <0.0.0> </pid>pipa
%                              <mailbox> .List </mailbox>pipa
%                              <processFlag> trap_exit |-> false </processFlag>
%                              <terminatedProcess> false </terminatedProcess>
%                          </process>
%                      </processes>
%                      <processIds> SetItem(<0.0.0>) </processIds>pipa
%                      <processesCheckMails> .Set </processesCheckMails>
%                      <idleProcesses> .Map </idleProcesses>
%                      <processesDuringExit> .Set </processesDuringExit>
%                      <registeredProcesses> .Map </registeredProcesses>pipa
%                      <linkedProcesses> .Map </linkedProcesses>
%                      <time> 0 </time>
%                      <defs color="blue"> .Map </defs>


%TODO
%	szemantika definíció kifejtése, plusz mindegyiknél mit jelent a kifejezés
%	milyen tesztek voltak hogy működik mennyire segített, honnan veszem, hogy azok helyesek?