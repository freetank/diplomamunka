\section{Erlang nyelv konkurens résznyelvének szemantikája $\mathbb{K}$ keretrendszerben}
Korábbi munkák eredményeként már létezett egy nyelvdefiníció, mely tartalmazta az alaptípusok egy részét, az ehhez tartozó operátorokat, a függvénydefiniálás és -hívás szemantikáját, mintaillesztést, néhány kifejezést mint például az \textit{if} és a \textit{case}, melyet részletesebben a \textit{Meglévő szemantikadefiníció} alfejezetben fejtettem ki. A meglévő nyelvdefiníció egy korábbi (3.6-os) verzióban volt meg, és szerettem volna legújabb verzió előnyeit kihasználni a diplomamunka kidolgozásakor.

\subsection{Meglévő szemantikadefiníció}
A meglévő szemantikadefiníciót modularizáltam, hogy a konkurens elemekkel együtt jól áttekinthető és kezelhető legyen.

\paragraph{tokens.k}
Ebben a fájlban van az Erlang specifikus literáloknak és a változóknak a szintaxisa, mely két modult tartalmaz.

\input{tex/Szabalyok/41TOKENS-PARSING}

A \textit{TOKENS-PARSING}, ahogy látható felül, az \textit{UnquotedAtom}, \textit{Atom}, \textit{Joker} és a \textit{Variable} fajtákat tartalmazza. A definíciók maguktól értetendőek. A \textit{Bool} és az \textit{UnquotedAtom} alfajtája az \textit{Atomnak}, viszont az aposztrófok közé írt atom nem, mivel egyelőre nincs definiálva. A \textit{Joker} és a \textit{Variable} definíciója ebben a modulban nem látható. Ennek az az oka, hogy a $\mathbb{K}$ keretrendszer rendelkezik egy \textit{\#KVariable} fajtával, amelynek a definíciójában megadott reguláris kifejezés által meghatározott lehetséges karakterláncok halmaza és a hasonló módon \textit{Variable} által meghatározott halmaz metszete nem üres, emiatt ha itt definiálnánk, parszolási hibát kapnánk.
\newline
\input{tex/Szabalyok/41TOKENS-SYNTAX}

A TOKENS-SYNTAX modulban megadva a definíciókat ezt a hibát elkerülhetjük. Ilyenkor a parszolás után kapott fán lévő levelek \textit{\#KVariable} címkéit lecseréli a saját \textit{Variable} fajtával.

\paragraph{exp-shared.k}
Az \textit{EXP-SHARED} modul az \textit{EXP} modulból -- később kerül ismertetésre -- leválasztott egység.

\input{\RULESFOLDER/41EXP-SHARED}

Az \textit{Exp} -- a kifejezések fajtája -- deklarálása itt található. Szinte az összes modul használja az \textit{Exp} és az \textit{Exps} fajtákat, viszont vannak olyanok, ahol szükségtelen az egész \textit{Exp}-hez tartozó szintaxist importálni. Ha a modulokban újra lenne deklarálva, az névütközéshez vezetne. Az \textit{EXP-SHARED} modul ezt hivatott elkerülni.

Ezen felül még definiálva lett az \textit{Exps} fajta, ami vesszővel elválasztott \textit{Exp}-ek sorozata a \textit{strict} attribútummal, mely a kötelező kiértékelést jelöli, sorrendet figyelmen kívül hagyva. A \textit{Match0} a \textit{case} és az \textit{if} kifejezések által is használt részkifejezések, amely a mintát és az utána lévő kifejezést tartalmazza, a \textit{Match} pedig ezek pontosvesszővel elválasztott sorozata. Fontos megjegyezni, hogy ezek a részkifejezések kiértékelése sorban történik. Vagyis mindig csak a mintaillesztés során a nyíl előtti rész, majd egyezés esetén pedig annak az "ágnak" a kifejezése értékelődik ki.

\paragraph{operators.k}
Az \textit{OPERATORS-PARSING} modulban bővítjük a kifejezések szintaxisát aritmetikai, összehasonlító és logikai operátorokkal.

\input{\RULESFOLDER/41OPERATORS-PARSING}

Az \textit{OPERATORS} modulban pedig az ezekhez tartozó szemantikadefiníciók találhatóak. Mivel a szintaxis esetén megadtuk minden egyes operátornál a \textit{strict} attribútumot, ezért a szabály alkalmazása várat magára egészen addig, amíg az operandusokat ki nem értékelte.

\input{\RULESFOLDER/41ARITHMETICS-EXAMPLE}

Ahogy a példában látható, az aritmetikai operátorok szemantikájának definiálása esetén nagy segítséget jelentenek a $\mathbb{K}$ keretrendszer beépített operátorai.

\paragraph{tuple.k}
Ebben a fájlban a \textit{tuple} típussal kapcsolatos szintaxis és szemantika található. A \textit{TUPLE-PARSING} modul bővíti az \textit{Exp} fajtát a \textit{tuple} szintaxisával.

\input{\RULESFOLDER/41TUPLE-PARSING}

A \textit{TUPLE} modul az \textit{OPERATORS} modul kibővítése \textit{tuple} specifikus összehasonlító operátorokkal.

\input{\RULESFOLDER/41TUPLE-EXAMPLE}

Egy strukturális átalakítás látható, ami jó példa arra, hogyan lehet felhasználni, a már meglévő szemantikadefinícióinkat újabbak definiálására.

\paragraph{list.k}

Az \textit{ERL-LIST-PARSING} modulban az Erlangban használatos lista két fajta szintaxisa található.

\input{\RULESFOLDER/41ERL-LIST-PARSING}

Az \textit{ERL-LIST} modul csak átalakítási szabályokat tartalmaz, melyet a \textit{macro} attribútum jelöl. Ezeket a keretrendszer a legelső számítási lépés előtt elvégzi.

\input{\RULESFOLDER/41ERL-LIST-EXAMPLE}

\paragraph{errors.k}

Az \textit{ERRORS} modul a futásidejű hibák fajtáit tartalmazza.

\input{\RULESFOLDER/41ERRORS}

\paragraph{value.k}

Előző modulokban látható, hogy szintaxis esetén egyes fajtákhoz \textit{strict} attribútum van rendelve. Ennek a következménye, hogy a szemantikai szabályok esetén csakis akkor illeszkedik egy minta, ha a keretrendszer a szabály előfeltételében szereplő összes fajtát a $\mathbb{K}$ specifikus \textit{KResult} fajtára átalakította. A \textit{VALUE} modulban ezeket gyűjtöttük össze a \textit{Value} fajtába.

\input{\RULESFOLDER/41VALUE}

\paragraph{exp.k}

Az \textit{EXP-PARSING} modul tartalmazza azon kifejezések szintaxisát, melyekhez lett szemantika definiálva.

\input{\RULESFOLDER/41EXP-PARSING}

Az \textit{EXP} modul pedig az ezekhez tartozó szemantikadefiníciókat tartalmazza.

\input{\RULESFOLDER/41EXP-EXAMPLE}

A kiemelt példában érdemes megfigyelni, ahogy a \textit{case} szabálya környezetet vált. A régit, amit a \textit{Rho} nevű változó jelöl, átemeli a számítási folyamba. Mikor a \textit{case} kifejezés visszatérési értékét megkapjuk, akkor ugyan ebből a folyamból visszaolvassa a régi környezetet.

\paragraph{erl-parsing.k}

Az \textit{ERL-PARSING} modul egyesíti az összes \textit{-PARSING} végű modult.

\input{\RULESFOLDER/41ERL-PARSING}

Ezen felül meghatározza a különböző kifejezések közötti prioritásokat is. Jelenleg az Erlang modul rendszer szintaxisa még nincs kidolgozva. Egy fájl felépítése két nagy részből áll: a függvénydefiníciós rész és a program rész, amit $---$ jel választ el egymástól.

\paragraph{erl.k}

Az \textit{ERL} modul három dologért felelős.

\input{\RULESFOLDER/41ERL-EXAMPLE-KRESULT}

Először is a \textit{Value} alfajtája lesz a \textit{KResult} fajtának.

\input{\RULESFOLDER/41ERL-EXAMPLE-PREPROCESSING}

Másodszor a program fájl feldolgozását definiálja. A függvénydefiníciós részt a későbbi függvény hívások miatt a \textit{defs} állapotba elmenti.

\input{\RULESFOLDER/41ERL-EXAMPLE-FUNCALL}

Harmadszorra pedig az általunk definiált függvények hívásának szemantikáját definiálja. Itt a megszokott módon környezetet vált, és a \textit{defs} állapotban megkeresi a hozzá tartozó függvénydefiníciót.

\paragraph{config.k}

Ebben a fájlban a kezdő konfiguráció található.

\input{\RULESFOLDER/41CONFIG}

A fenti kezdő konfiguráció ezen diplomamunka előtti állapotot mutatja. A \textit{k} cella tartalmazza az adott konfigurációban a hátralévő programot. Az állapot jelenleg két parciális függvényből áll. 
\begin{align*}
defs: Atom \rightarrow Lista \quad \textrm{ahol} \quad Lista \subseteq \{f | f : Exps \rightarrow Exp\}
\end{align*}

Ahogy feljebb olvasható a \textit{defs} tartalmazza a függvénydefiníciókat: a függvény nevéhez hozzárendeli a lehetséges függvénytörzseket. Itt a \textit{Lista} alatt a $\mathbb{K}$ keretrendszer beépített listája értendő.
\begin{align*}
env: Variable \rightarrow Value
\end{align*}

Az \textit{env} függvény pedig a változó nevéhez hozzárendeli a változóhoz kötött értéket.

Ebben az alfejezetben egy rövid és tömör áttekintést kaphattunk a már meglévő szemantikadefiníciókról. Mielőtt tovább haladnánk, hogy megismerjük a konkurens résznyelvhez tartozó szemantikadefiníciókat, érdemes egy rövid betekintést nyerni az Erlang nyelv folyamatainak világába.

\subsection{Erlang folyamatok}
Az Erlang nyelv fő erőssége a konkurens és az elosztott programozásban rejlik. Konkurencia alatt a különböző szálak egy idejű kezelését értjük. Ez természetesen lehet valós párhuzamos megvalósítású több magos gépek esetén, illetve főként egy magos környezetben a szálak folyamatos cserélgetésével, így a párhuzamosság látszatát kapjuk. Ilyen szálakat Erlang nyelven könnyedén létrehozhatunk és eszközt is ad az egymás közötti kommunikációra. Erlangban ezeket a szálakat folyamatoknak hívjuk. Ez logikus megnevezés mivel a folyamatok egymással nem osztanak meg közvetlenül adatot. Az információcsere folyamatok között üzenetküldéssel történik.

Egy ilyen folyamatot a \textit{spawn(Modul, Exportált\_Függvény, ArgumentLista)} hívással tudunk létrehozni.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn.erl}

A \textit{representSpawn} modul egy egyszerű példát mutat a spawn használatára. A \textit{start} függvénye három darab folyamatot indít el egymás után, ami függetlenül fog futni a létrehozó folyamattól. Ha meghívjuk a start függvényt az egyik lehetséges eredmény az alábbi lehet.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/spawn_start.erl}

Látható hogy a kiírás sorrendje ebben az esetben 8, 10, 9. Ezen a sorozaton jól látható, hogy a folyamatok egymástól függetlenül futnak, mivel a processzor úgy ütemezett, hogy a 4-es argumentummal meghívott folyamat írja ki az eredményét a legkésőbb. A zárójelben ponttal elválasztott számok a folyamatazonosító. Minden folyamathoz tartozik egy ilyen egyedi azonosító, ami a \textit{spawn} függvény visszatérési értéke.

Mivel a folyamatok nem osztják meg közvetlenül saját adataikat, az egymással való kommunikáció üzenetküldéssel folyik. Ezt legegyszerűbben a klasszikus ping-pong példán lehet bemutatni \cite{RefMan}.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong.erl}

A példában két folyamat kommunikál egymással. Az üzenet, akár egy ping pong labda, halad az egyik folyamattól a másik folyamatig. A \textit{start} függvény hozza létre a két folyamatot, amelyek kommunikálnak egymással. Az első folyamat, amit létrehoz, a \textit{pong} függvényt hívja meg, és eltárolja a folyamatazonosítóját egy változóba.

A \textit{pong} függvény egy \textit{receive} kifejezést tartalmaz. Ez a szerkezet felelős az üzenetek fogadásáért. Minden folyamathoz tartozik egy postaláda, amibe az üzenetek érkeznek. Ezeken a \textit{receive} minden ágára, kezdve az elsővel, mintaillesztést végez a beérkezésük sorrendjében, amíg egyezést nem talál. Ha sikeres volt a mintaillesztés, akkor azt az üzenetet eldobja a postaládából, és az adott ághoz tartozó kifejezést kiértékeli. Ha nem volt egyezés, vár amíg újabb üzenet nem jön, és újra a legrégebbi üzenettől kezdi el a mintaillesztést. Jelen esetben nagy valószínűséggel a \textit{pong} folyamat postaládája üres, ezért üzenetfogadására vár.

A \textit{start} létrehozza a második folyamatot, ami a \textit{ping} függvényt hívja meg két paraméterrel, egy számmal és egy folyamatazonosítóval. Az első paraméter megadja, hogy az üzenetküldés hányszor menjen végbe oda-vissza, a második paraméter pedig egy folyamatazonosító, amely folyamattal kommunikálni fog. A \textit{ping} függvényben az első kifejezés a ! operátor. A két aritású operátorban az első operandusban megadott folyamatazonosító által meghatározott folyamatnak elküld egy a második operandusban megadott üzenetet. Itt az üzenet egy \textit{tuple}, ami egy atomot és a \textit{self} függvényt tartalmazza. A \textit{self} visszaadja az adott folyamat folyamatazonosítóját.

Ezalatt a másik várakozó folyamat üzenetet kapott a \textit{ping} függvényt kiértékelő folyamattól. A második ágra illeszkedik az üzenet így kiírja hogy megérkezett, és nyomban válaszol is rá a ! operátorral. A válasz már csak egy atom, mivel a \textit{ping} függvényt kiértékelő folyamat paraméterként megkapta a folyamatazonosítót. Ezután rekurzívan meghívja önmagát. Ekkor a \textit{ping} vagy épp most kezdi el a \textit{receive} kiértékelését, vagy már el is végzett egy mintaillesztést, és egy új üzenetre vár. A kapott üzenet illeszkedik a \textit{pong} atomra így jelzi, hogy az üzenet megérkezett, és a függvény szintén rekurzívan meghívja önmagát, ám az üzenetküldés számát meghatározó paraméter értékét csökkenti eggyel. Ez egészen addig megy így, amíg ez az érték nulla nem lesz. Ekkor a \textit{ping} másik paraméterezésére fognak illeszkedni a függvényhívásban megadott paraméterek. A \textit{finished} atomot tartalmazó üzenetet küldi el, ami jelzi a \textit{pongnak}, hogy az üzenetküldések folyamatának vége. Mind a két függvény kiírja, hogy befejeződött az üzenetküldés, és már nincs rekurzív hívás, így a függvények kiértékelődtek, a két folyamat terminál.

Lefuttatva a példa programot, feltételezve hogy a konzolra való kiíratást egyből végrehajtja, az alábbi eredményt kapjuk.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/pingpong_start.erl}

Ezzel az áttekintővel egy kép alakult ki a folyamatok működéséről és kommunikációjáról, ami minimálisan szükséges a konkurens szemantikadefiníciók könnyebb megértéséhez. A diplomamunka nem tér ki a több gépet tartalmazó elosztott programozásra.

\subsection{Konkurens résznyelv szemantikája}

Szemantikadefiniálás gyakorlatilag a manuál értelmezéséből áll, amiből aztán megfelelő módszerrel, technikával formális szemantikadefiníciót készítünk. Ebben az alfejezetben megvizsgáljuk, hogy a nyelvi elemekhez, amihez formális szemantikát akarunk definiálni, milyen informális leírás tartozik, és ezek alapján hogyan jutunk el a formális definícióig. A konfiguráció is bővült.

\input{\RULESFOLDER/43CONFIG}

\input{\RULESFOLDER/43CONFIG_PROCESS}

A kezdő konfiguráció kiegészült pár állapottal:

\begin{itemize}
  \item processes: a folyamatok csoportját tároló cella
  \begin{itemize}
    \item process: folyamatok állapota
    \begin{itemize}
      \item k: a programot szekvenciákra bontott listaként tároló cella
      \item env: a változókhoz hozzárendelt értékek az adott környezetben
      \item pid: folyamatazonosító
      \item mailbox: a folyamat postaládája
      \item processFlag: folyamathoz tartozó flagek és értékei
      \item terminatedProcess: jelzi hogy a folyamat terminált-e
    \end{itemize}
  \end{itemize}
  \item processIds: a futó folyamatok azonosítói
  \item processesCheckMails: folyamatok azonosítói, melyek mintaillesztést végeznek a postaládában lévő üzeneteikre
  \item idleProcesses: üzenetre várakozó folyamatok azonosítói, és a hozzájuk tartozó lejárati idő
  \item processesDuringExit: az éppen termináló folyamatok azonosítói
  \item registeredProcesses: a regisztrált folyamatok azonosítói és a hozzátartozó nevek
  \item linkedProcesses: egymáshoz kapcsolt folyamatok
  \item time: az eltelt idő
  \item defs: függvénydefiníciók
\end{itemize}

A cellák bővebb leírása és tartalma azoknál a definícióknál lesz kifejtve, ahol először megjelennek. A résznyelv egész szemantikadefiníciója megtekinthető a diplomamunka mellékletében.

\subsubsection{Folyamat létrehozása}
A folyamatok létrehozásáról az előző alfejezetben már tettem említést, ami a spawn függvénnyel lehetséges. A konfigurációban a \textit{processes} állapot tartalmazza a folyamatokat, ami gyakorlatilag egy multihalmaz (a multihalmaz jellege sose lesz kihasználva, mivel a folyamatazonosító mindig egyedi minden folyamatnak, emiatt nem létezhet két azonos elem a multihalmazban). Minden sikeres spawn híváskor egy új \textit{process} elem kerül be a konfigurációba. Ez a process tartalmazza a már említett k cellát és az env állapotot.

A spawn függvénynek négyféle paraméterezése létezik. A három paraméterből álló szemantikadefiníciója lett megvalósítva. Az első paramétere a modul neve, amiben a függvény található. Mivel a modul rendszer szintaxisa és szemantikája még nem lett definiálva $\mathbb{K}$ keretrendszerben, emiatt az itt lévő atomot mindig figyelmen kívül hagyjuk. Második paramétere a függvény neve, harmadik pedig egy lista, ami a második paraméterben meghatározott függvény aktuális paramétereit tartalmazza. A konfiguráció átmenet létrehoz egy új process elemet, vagyis egy új folyamatot, a kezdőkonfiguráció szerinti állapot szerint. Egyedül a k cellát és a \textit{pid} állapotot módosítja. A k cellába a függvény hívás kerül a megadott paraméterekkel, amit a \textit{GetCommaSeparatedValuesFromList} szemantikus függvény a megfelelő alakra hoz, vagyis az átadott listából egy Values fajtára alakít. A pid állapot pedig egy egyedileg generált folyamatazonosítót fog tartalmazni, ami szintén bekerül \textit{processIds} állapot halmazába. A processIds a futó folyamatok folyamatazonosítóinak a listája. Egyelőre csak a helyes működés van definiálva, a függvény által dobott futásidejű hibák nincsenek. Ilyenek például, ha rossz függvény nevet, vagy aritású függvényt adunk meg.

\input{\RULESFOLDER/43SELF}

A self függvény szemantikadefiníciója egy szabályból áll, ami fent látható. A self visszatérési értéke az éppen futó folyamat folyamatazonosítója. A szabály a saját process cellájában lévő pid állapotra illeszkedik, és ezt az egyedi azonosítót tartalmazza a k cella az átmenet után, amit a folyamat létrehozásakor generáltunk.

\subsubsection{Folyamatok azonosítása}

A folyamatokra a már előbb bemutatott folyamatazonosítóval is tudunk hivatkozni, ám nevesíthetjük is azokat, a két paraméteres \textit{register} függvénnyel. Az első paramétere az általunk választott név, ami egy atom, a második pedig a folyamatazonosító, amit ehhez a névhez szeretnénk társítani. Visszatérési értéke mindig true. \textit{badarg} futásidejű hibát okozhat az alábbi esetekben:

\begin{itemize}
\item ha az első argumentumban megadott névhez már lett folyamat rendelve
\item ha a második paraméterben megadott folyamatazonosító nem létezik
\item ha a második paraméterben megadott folyamatazonosítóhoz már rendeltünk nevet
\item ha az első paraméter az \textit{undefined} atom
\end{itemize}

A függvénnyel több gépet tartalmazó környezetben folyamatazonosító helyett portot is átadhatunk paraméternek. Ahogy már említettem, a szemantikadefiníció nem tér ki az ilyen esetekre.

Ehhez a szemantikadefinícióhoz három szabály is tartozik.

\input{\RULESFOLDER/43REGISTER}

Két szabály a sikeres név-folyamatazonosító hozzárendelése esetén, egy pedig a badarg futásidejű hiba esetén való átmenet. A fenti szabály a sikeres hozzárendelés nem saját folyamatazonosító esetén. Látható, hogy egy másik folyamat pid cellájára illeszkedik, amit a \textit{P} változóba ment el, és a hozzátársított névvel (\textit{Name}) a \textit{registeredProcesses} állapot map-ét bővíti az átmenet. Ez az állapot név-folyamatazonosító párokat tartalmaz, ami a nevekhez való társításokat tárolja. Az illeszkedés esetén való feltételt érdemes részletesebben megvizsgálni. Ez gyakorlatilag az előbb listaként felsorolt állítások tagadásai. Az \textit{RP}-ben lévő párok nem tartalmazhatják külön a regisztrált nevet, illetve a folyamatazonosítót, nem lehet a név undefined atom, és a folyamatazonosítónak benne kell lennie az Ids halmazban, ezzel kötjük ki, hogy csak futó folyamatokhoz tudunk nevet társítani.

A másik sikeres szabály hasonló az előzőhöz, azzal a kivétellel, hogy itt a folyamat a saját azonosítójához akar nevet társítani, így nem egy process cella pid állapotára illeszkedik, hanem a sajátjáéra. A badarg futásidejű hibát kiváltó szabály esetén a k cellában lévő átmenet ezt a hibát adja, a feltételek pedig az előző szabályokénak a negáltja.

Az így regisztrált nevek lekérhetőek a \textit{registered} paraméternélküli függvénnyel. A neveket egy listában adja vissza.

\input{\RULESFOLDER/43REGISTERED}

A fent látható szabály a \textit{registeredProcesses} állapotra illeszkedik, és az \textit{RP} változóba olvassa be a név-folyamatazonosító párokat. A \textit{fromSetToErlList} szemantikus függvény a paraméterként átadott neveket tartalmazó halmazból Erlang listát képez, ami az átmenet eredménye lesz a k cellában.

A \textit{whereis} függvény megadja a paraméterben átadott atomhoz tartozó folyamatazonosítót. Ha még nem volt hozzárendelés az undefined atommal tér vissza.

\input{\RULESFOLDER/43WHEREIS_UNDEFINED}

A szemantikadefiníció két szabályból áll. A fenti írja le a működést abban az esetben, ha az atomhoz nincs hozzárendelve folyamatazonosító. Az illeszkedéssel az \textit{RP} változóba beolvassa a regisztrált név-folyamatazonosító párokat, és ha a nevekből alkotott halmaz nem tartalmazza a \textit{Name} változóban lévő atomot, akkor a k cellában az átmenet az undefined atomot adja. A másik szabály találat esetén visszaadja a Name-hez rendelt folyamatazonosítót a mapből.

A register függvény segítségével létrehozott név-folyamatazonosító társítást törölhetjük az \textit{unregister} segítségével. Visszatérési értéke mindig \textit{true}. Ha a paraméterében átadott atomhoz nincs folyamatazonosító rendelve, akkor \textit{badarg} futásidejű hibát okoz.

\input{\RULESFOLDER/43UNREGISTER}

Itt is két szabályból áll a definíció. Ha már volt regisztrálva a \textit{Name} változóban lévő atom, akkor a fent látható szabály illeszkedik. Az \textit{undef} segítségével tudunk egy map-ben lévő kulcs értéket törölni a hozzárendelt értékeivel együtt. A második szabály átmenete természetesen a \textit{badarg} futásidejű hibához vezet.

\subsubsection{Üzenetküldés és -fogadás}

Ahogy már korábban említésre került a folyamatok üzenetekkel tudnak egymással kommunikálni. Egy üzenetet a ! operátorral küldhetünk, melynek mindkét operandusa kifejezés. Az első kiértékelése után folyamatazonosítónak vagy egy atomnak kell lennie, ám ebben az esetben előzőleg egy folyamatazonosítót kell regisztrálnunk a \textit{register} függvénnyel különben \textit{badarg} futásidejű hibát kapunk. Azonban akármilyen folyamatazonosítónak küldünk üzenetet, akár ténylegesen azonosít egy folyamatot akár nem, az üzenetküldés nem okoz futásidejű hibát. Az operátor visszatérési érték az üzenet.

Ehhez már bonyolultabb szemantikadefiníció tartozik 6 szabállyal. Ezek közül ötöt ismertetek, majd a \textit{receive} bemutatása közben pedig az utolsót is.

\input{\RULESFOLDER/43SENDTOOTHER}

Az üzenetküldéskor leggyakrabban használt eset szabálya látható felül. A \textit{P} változóban lévő folyamatazonosító által meghatározott folyamatnak küldi el a \textit{V} változóban lévő értéket. Az illeszkedés a \textit{P} szerinti változó alapján történik, tehát illeszkedik a ! operátor kiértékelt első operandusára, és egy másik folyamat pid állapotára, emiatt látható a második process cella. Itt az átmenet a mailbox állapot listájának a végére fűzi a \textit{V} üzenetet. A mailbox a folyamatokhoz tartozó postaláda állapota, a beérkező üzeneteket időrendben tároló lista. A feltétel második része érdekes csak most számunkra, ami azt mondja meg hogy az adott \textit{P} folyamat tényleg létezik-e. Hasonló a szabály akkor is, ha egy folyamat saját magának akar üzenetet küldeni. Ekkor a szabály a saját pid állapotára illeszkedik, és az átmenet a saját üzeneteinek a végéhez fűzi az üzenetet. A harmadik szabály feltétele azt mondja ki, hogy az adott \textit{P} folyamat nem létezik, így a k cella átmenete végbemegy, az üzenet lesz a cél, de semmi változás sem történik egyik folyamat postafiókjában sem.

\input{\RULESFOLDER/43SENDTOREGISTER}

A maradék két szabály a regisztrált névnek való üzenetküldésről szól. Fent látható, ha létezik regisztrált név a \textit{registeredProcesses} állapotban, akkor a névből a hozzárendelt folyamatazonosítóba megy az átmenet. Itt feltétel sem szükséges, mivel az illeszkedés csak akkor történik meg, ha létezik az a bizonyos név-folyamatazonosító társítás. A \textit{badarg} futásidejű hibát kiváltó szabály esetén ha a \textit{registeredProcessses} állapotban lévő mapben nincs hozzárendelve a névhez az adott kulcs, az azt jelenti, hogy nem regisztrált név, így az üzenetküldés \textit{badarg} futásidejű hibát ad a k cella átmenetében.

Az üzenet fogadása a \textit{receive} kifejezéssel történik. A postaládában lévő üzenetekre sorban mintaillesztést végez. Először a legrégebbit veszi ki és felülről lefelé haladva elvégzi a \textit{receive} ágaira. Ha az illesztés sikeres volt, és a hozzátartozó őrfeltétel is igaz, akkor kiértékeli a hozzátartozó ágat, és a kifejezés értéke az ág értéke lesz. Az üzenetet ekkor eldobja a postaládából. Ha nem volt sikeres mintaillesztés folytatja a másodikkal, és így tovább. A \textit{receive} soha sem dob futásidejű hibát, vagyis ha egyik üzenetre sem volt sikeres a mintaillesztés, vagy sikeres volt, de a hozzátartozó őrfeltétel nem volt igaz, akkor a folyamat addig vár, amíg új üzenet nem érkezik, és kezdődik minden elölről. A hozzátartozó szemantikadefinícióban nem foglalkozunk az őrfeltételekkel, a szintaxis sem tartalmazza egyelőre.

\lstinputlisting[language=Erlang]{\EXAMPLESFOLDER/receive.erl}

A kifejezés tartalmazhat egy \textit{after} klózt, ahol az \textit{ExprT} kifejezés értéke egy nullánál nagyobb vagy egyenlő szám, vagy az \textit{infinity} atom. Ellenkező esetben \textit{badarg} futásidejű hibát kapunk. Ha van \textit{after}, akkor a sikertelen mintaillesztések után ennyi milliszekundumig vár a folyamat új üzenetre. Ha az idő letelt, akkor az \textit{after} utáni \textit{BodyT} lesz kiértékelve, ami a \textit{receive} visszatérési értéke lesz. Az \textit{infinity} atom esete, ugyanolyan, mint ha nem lenne \textit{after} klóz. Ez az eset az \textit{ExprT} futásidőben való kiértékelésekor kap értelmet, hiszen így \textit{after} klóz esetén is tudjuk szimulálni az \textit{after} nélküli kifejezést.

Az \textit{after} klóz szemantikadefiníciójához szükséges az eltelt idő ismerete. Sajnos a $\mathbb{K}$ keretrendszer jelenleg nem támogatja ezt semmilyen módon, így a szemantika részeként kellett megvalósítani. A már látott szemantikadefiníciókban feltűnhetett a \textit{time} állapot, ami a program indítása óta eltelt időt jelenti milliszekundumban. Ám ez az idő relatív. Minden egyes utasítás növeli a time állapot értékét. Jelenleg ez egységesen 10 milliszekundum. Így egy fajta időmúlás érzetét kapjuk, ami természetesen, ahogy említettem relatív, vagyis nem azonos a való világban eltelt idővel.

Főleg az \textit{after} klóz miatt ez az egyik legbonyolultabb szemantikadefiníció, amit tartalmaz a diplomamunka. A különböző \textit{receive} szintaxisok egységes kezeléséért lett bevezetve az alábbi \textit{After} fajta.

\input{\RULESFOLDER/43DOLLARAFTER}

Az első paraméter tartalmazza az \textit{after} klózban meghatározott időt. Azért \textit{Exp} fajta nem pedig \textit{Int}, mert az \textit{infinity} atomot is tartalmazhatja. A második paramétere az \textit{after} klóz törzse, a harmadik pedig az az időpont, amikor a \textit{receive} kiértékelése elkezdődött.

\input{\RULESFOLDER/43RECEIVESTRUCTURAL}

Minden \textit{receive} híváskor egy strukturális átalakítást végző szabály illeszkedik először, ami a megfelelő átalakítást végzi. Fent látható a négy szabály közül az egyik. Ez az az eset, amikor nincsen \textit{after} klóz. Látható a \textit{k} cella átmenetében, hogy a számítási folyamba betesszük az előbb említett \textit{\$after}-t a megfelelő paraméterekkel. Itt az \textit{infinity} atomot adjuk meg első paraméterben, második paraméterként pedig \textit{undefined} atomot, mivel nincs \textit{after} klóz, így nincs is kifejezés, amit ki kellene értékelni. Az idő állapotot lekérjük, és harmadik paraméterként adjuk át. Egy új állapotot fedezhetünk fel, ami a \textit{processesCheckMails}. Ez azoknak a folyamatoknak a halmaza, amelyek éppen \textit{receive} kifejezés esetén a mintaillesztést végzik, tehát nem várakoznak üzenetekre. Ez a szabály csak is akkor illeszkedik, ha még csak most ér a folyamat a \textit{receive} kifejezéshez. Ennek oka az, hogy a strukturális átalakítások alatt lecsípjük az \textit{after} részt, így a különböző szintaxisú \textit{receive} kifejezések azonos formájúak lesznek a számítási folyamban, és egy már átalakított kifejezést nem akarunk még egyszer strukturálisan átalakítani, akár többször is. Mivel minden formájú \textit{receive} kifejezés azonos lesz, a szemantikáját egységesen lehet definiálni. Természetesen már strukturális átalakítás során kiszűrjük a rossz argumentumú \textit{after} klózt.

Üzenetfeldolgozásért három szabály felelős, egy amely sikeres mintaillesztés esetén illeszkedik, kettő pedig mikor sikertelen. Az egyik sikertelen esetet kezelő szabályról fogok részletesebben beszélni.

\newpage

\input{\RULESFOLDER/43RECEIVENOTMATCHED}

A feltételben lévő \textit{callMatchesToListOfValues} végzi a mintaillesztést az üzenetekre. Ebben az esetben nem volt sikeres mintaillesztés, vagyis \textit{\$error\_badmatch}-al tér vissza. A feltétel második része mondja ki, hogy csak azokra a folyamatokra illeszkedik ez a szabály, amelyeken a strukturális átalakítás lefutott, és készek rá, hogy megvizsgálják a postaládájukat. Hisz látható, hogy az előző szabályban és ebben a szabályban is a \textit{k} cella eleje azonos, így ha ez a feltétel nincs, nem determinisztikusan illeszkedhet az egyik illetve a másik szabály. Mivel ez a szabály a postaládában lévő üzenetek mintaillesztését elvégzi, ezért az átmenet kiveszi a \textit{processesCheckMails} állapotból a folyamat azonosítóját. Az átmenet a folyamatot várakoztató állapotba rakja. Ez két helyen is jelölve van. Az egyik a \textit{k} cella átmenete, ahol a számítási folyamba berakja a \textit{\$wait\_msg} konstanst, ami a későbbi szabályillesztésnél ad segítséget, illetve az \textit{idleProcesses} állapotba berakja a folyamatazonosító-lejárati idő párt. Az \textit{idleProcesses} állapot egy map, ahova a folyamatokhoz hozzárendel egy lejárati időt. Ezután a folyamat várakozik. Itt jön a képbe a hatodik szabálya a ! operátor szemantikadefiníciójának.

\newpage

\input{\RULESFOLDER/43SENDTOIDLEPROCESS}

Mivel ez egy külön eset, külön szabály is tartozik hozzá. Ha egy folyamat várakozik, amit a \textit{\$wait\_msg} alapján is tudunk, akkor az üzenetküldés fogja beindítani, a \textit{k} cella átmenetében, az újbóli feldolgozását a postaládában lévő üzeneteknek. Figyeljük meg az \textit{idleProcesses} és a \textit{processesCheckMails} állapotok változásait. A folyamat többé nem várakozó folyamat, hanem az üzeneteit vizsgáló folyamat. Ezen kívül még egy eset létezik (a kívülről jövő termináló üzeneten kívül) a várakozó folyamat állapotból való kiléptetésre, mégpedig ha az ideje lejárt.

\input{\RULESFOLDER/43TIMEISUP}

A szabály csak várakozó folyamatokra illeszkedik. Ha a \textit{\$after} harmadik paramétere, vagyis a \textit{receive} hívásának kezdetének ideje és az \textit{after} klózban tartalmazott idő, ami az első paraméter, összege nagyobb, mint a \textit{time} állapotban lévő idő, akkor többet nem vár a folyamat illeszkedő üzenetre, hanem az \textit{after} klóz törzsét kiértékeli. Ekkor az \textit{idleProcesses} állapotból kiveszi az adott folyamatazonosító-idő párost, ezzel jelezve, hogy már nem várakozó folyamat az alábbi.

Ezzel gyakorlatilag az üzenetküldés és -fogadás szemantikadefinícióját majdnem teljesen egészében lefedtük, viszont egy megválaszolatlan kérdés maradt. Mi történik akkor, hogy ha az összes folyamat üzenetre várakozik. Ha mindegyik \textit{infinity} atommal lett meghívva, vagy \textit{after} klóz nélkül, akkor a végtelenségig vár, a programunk megakadt, de ha legalább egy folyamat \textit{after} klózában egy számot adtunk meg, akkor az idő letelte után az utána lévő kifejezést ki kell értékelnie. A probléma az, hogy mivel minden folyamat vár, tehát számítási lépés nem hajtódik végre, ezért nem fog telni az idő, vagyis nem növeli egy szabály sem az idő állapotban lévő értéket.

\input{\RULESFOLDER/43TIMEISTICKING}

Itt fellelhető néhány állapot, melyek később lesznek ismertetve. A lényegi rész a feltételben és a \textit{k} cellában található. Ha minden folyamat várakozik, akkor minden folyamat \textit{k} cellájában a \textit{\$wait\_msg} található. Ez a szabály bármelyik várakozó folyamatra tud illeszkedni. Ha az \textit{idleProcesses} állapotban lévő elemek száma megegyezik a \textit{processIds} állapot elemeinek számával és az éppen illeszkedett folyamatra hívott \textit{isStillIdle} szemantikus függvény igazat ad, akkor az átmenet növeli a \textit{time} állapot értékét, vagyis telik az idő. A feltétel első fele azt mondja ki, hogy ugyanannyi futó folyamatunk van, mint amennyi várakozik, tehát minden futó folyamatunk várakozik, a második pedig megvizsgálja, hogy a várakozó folyamatok közül van-e olyan, amelynek már letelt az ideje, vagyis az \textit{after} rész kiértékelhető-e már.

Ezzel körbe is jártuk az üzenetküldés és -fogadás szemantikadefinícióját. Ezt az összetett működést összesen 15 szabály segítségével adtuk meg.

\subsubsection{Folyamatok közötti kapcsolatok}

A folyamatok között kialakítható egy kölcsönös kapcsolat a \textit{link} függvénnyel, melyet párjával az \textit{unlink}kel meg tudunk szüntetni. Ezek a kapcsolatok a folyamatok terminálásának kezelésére alkalmasak. Ha egy folyamat terminál, akár futásidejű hibával akár nem, akkor az összes hozzákapcsolt folyamatot értesíti erről. A \textit{link} függvény mindig \textit{true} atommal tér vissza. Egyetlen paramétere a folyamatazonosító, amely között a hívó folyamat kapcsolatot akar létrehozni. Ha már létezik, akkor nem fog létrehozni újat, mivel minden folyamat között csak egy kapcsolat lehet. Saját magával nem tud kapcsolatot létrehozni. Ha a paraméterben megadott folyamatazonosítóhoz nem tartozik futó folyamat, akkor két lehetőség létezik. Ha a \textit{trap\_exit} flag értéke hamis, akkor a \textit{noproc} futásidejű hibát adja, ha viszont igaz, a hívó folyamat egy üzenetet kap mégpedig az alábbi formában:

\begin{lstlisting}[language=Erlang]
{'EXIT', Folyamatazonosito, noproc}
\end{lstlisting}

A \textit{trap\_exit} flagről később lesz szó.

\input{\RULESFOLDER/43LINK1STSTEP}

A folyamatok közötti kapcsolat kialakítása két lépésből áll. A \textit{linkedProcesses} állapotban, ami egy map, tárolja a kapcsolatokat. Egy folyamatazonosítóhoz egy folyamatazonosítókat tartalmazó halmazt rendel. Először, ahogy fent látható, a \textit{link} függvény a hívó folyamathoz rendeli a paraméterben átadott folyamatazonosítót. Az illeszkedés csak akkor sikeres, ha ehhez a folyamathoz létezik már ilyen kapcsolat. A hozzátartozó halmazt bővíti az első paraméterrel. Abban az esetben, ha már létezik kapcsolat a két folyamat között, ez a lépés gyakorlatilag nem fog semmi újat hozzáadni a \textit{linkedProcesses} állapothoz, mivel a halmaz tulajdonság miatt nem lesz két ugyanolyan eleme, vagyis nem lesz két kapcsolat ugyanazon folyamatok között.

A második lépés is hasonló. Ahogy láthattuk a \textit{k} cella átmenete a \textit{\$link}. Ez azért szükséges, mert jól el kell határolni az első folyamathoz való hozzárendelést a másodiktól. Az ok az, hogy előfordulhat az az eset, amikor az egyik folyamathoz már létezik kapcsolat, vagyis a \textit{linkedProcesses} állapotban megtalálható, viszont a második folyamathoz még nem létezik, így új elemként kell beszúrni ebbe az állapotba. A \textit{linkedProcesses} állapot redundánsan tartalmazza az információt a kapcsolatokról, viszont az ilyen fajta tárolás megkönnyíti az adatok kezelését.

A \textit{spawn\_link} függvénnyel egy lépésben hozhatunk létre új folyamatot, és kapcsolhatjuk össze a hívó folyamattal.

\input{\RULESFOLDER/43SPAWNLINK}

Fent látható a \textit{spawn\_link} szemantikadefiníciója. Az ok, amiért ilyen bonyolult szabályhalmazzal lehetett megoldani ezt a definíciót az az, hogy a link függvény a \textit{true} atommal tér vissza, míg a \textit{spawn\_link} a létrehozott folyamat azonosítójával, emiatt nem lehet egyszerűen csak paraméterként átadni a \textit{spawn} visszatérési értékét a \textit{link} függvénynek. Egy speciális \textit{Exp} fajta segítségével, ami a \textit{\$spawn\_link}, egy saját kontextust hoz létre a számítási folyamban, így csak az alsó három szabály tud illeszkedni rá. A második paramétere rendelkezik \textit{strict} attribútummal, tehát a strukturális átalakítás után egyből elkezdi kiértékelni a \textit{spawn} függvényt. A \textit{?HOLE} egy ismeretlen változót jelöl, ami gyakorlatilag megfelel a joker karakternek, ám tudunk a szabályokban hivatkozni rájuk. Abban az esetben, ha kiértékelődött a függvény és a változó nem \textit{Pid} fajtájú, akkor az első paraméter helyére berakja a második paraméterben értékként kapott folyamatazonosítót, tehát elmenti, hogy vissza tudjon térni vele, míg a második paraméterbe pedig berakja a \textit{link} függvényt ugyanezzel a folyamatazonosítóval. Most már a \textit{link} a második paraméter, ezért ki kell értékelnie a keretrendszernek, mielőtt foglalkozna a \textit{\$spawn\_link}-kel. Mivel az első paraméter folyamatazonosító, csak az utolsó kettő szabály tud illeszkedni a számítási folyamra. Előfordulhat az az eset, amikor a linkelés még be sem fejeződött, de a létrehozott folyamat már terminált is. Ebben az esetben a \textit{link} függvény \textit{noproc} futásidejű hibát dob, ez viszont nem releváns, mivel csak a hívó folyamat volt lassú, de a \textit{spawn\_link} atominak tekinthető. Az utolsó szabály pont ezt küszöböli ki.

Az utolsó függvény az \textit{unlink}, ami törli a kapcsolatot két folyamat között, ha létezik. Ha nem létező folyamat azonosítóját adjuk meg paraméterként, akkor sem kapunk futásidejű hibát, minden esetben a \textit{true} atommal tér vissza. Ha a \textit{trap\_exit} igazra van állítva, akkor még az alábbi üzenetet is be fogja rakni a hívó folyamat postaládájába.

\begin{lstlisting}[language=Erlang]
{'EXIT', Id, _}
\end{lstlisting}

A következő alfejezet a folyamatok terminálásának viselkedését és szemantikadefinícióját mutatja be, mellyel még világosabbá válik a folyamatok közötti kapcsolatok jelentősége.

\subsubsection{Folyamatok terminálása}

A folyamatok változatos formában képesek terminálni. Ennek egyik fajtája az egy és kettő aritású \textit{exit} függvény. Az egy paraméteres változat a hívó folyamatot terminálja, mégpedig a paraméterben megadott indokkal. A két paraméteres változattal a második paraméterben megadott folyamatazonosító által identifikált folyamatot terminálhatjuk. Véget érhet még futásidejű hibával is, illetve gond nélkül, mikor már nincs mit kiértékelni. Itt jönnek képbe a folyamatok közötti kapcsolatok.

Amikor egy folyamat terminál, akkor a vele összekötött folyamatoknak küld egy szignált a terminálás okával. Ezek a folyamatok többféleképpen reagálhatnak erre a szignálra. Függ a terminálás okától és a \textit{trap\_exit} flag értékétől is. Erről a flagről már olvashattunk korábban. A két paraméteres \textit{process\_flag} függvénnyel állítható az értéke. Első paraméterként azt a flaget jelölő atomot adjuk meg, aminek értékét szeretnénk megváltoztatni, másodikként pedig az értéket. Visszatérési értéke a flag előző értéke lesz. Ezzel a függvénnyel beállított flageket a \textit{processFlag} állapot tárolja, ami egy map, mégpedig a flagekhez rendelt értékek. Ha nem létező flagnek akarunk értéket adni, a függvény \textit{badarg} futásidejű hibát dob. Ha a \textit{trap\_exit} értéke \textit{false}, akkor ha exit szignált kap, melynek oka nem \textit{normal} atom, akkor a folyamat is terminál és értesíti erről egy ugyan ilyen szignállal a hozzá kapcsolt folyamatokat. A \textit{normal} atom esetén nem csinál semmit. Ha az érték \textit{true}, akkor ha a kilépésnek oka nem \textit{kill}, a szignált üzenetként fogja megkapni, az alábbi formában:

\begin{lstlisting}[language=Erlang]
{'EXIT', Folyamatazonosito, TerminalasOka}
\end{lstlisting}

A \textit{Folyamatazonosito} annak a folyamatnak az azonosítója, amely küldte a szignált, a \textit{TerminalasOka} pedig az ok, amiért a folyamat terminált. Ha ez az ok \textit{kill}, akkor a folyamat nem tudja üzenetként fogadni a szignált, úgy viselkedik, mint ha ez a flag \textit{false} értékre lenne állítva.

\input{\RULESFOLDER/43PROCESSTERMINATIONWITHOUTLINK}

Fent látható a terminálásnak a legegyszerűbb esete. A feltételből látszik, hogy ez a folyamat nincs összekapcsolva egy folyamattal sem, emiatt nem küld exit szignált. Az átmenet gyakorlatilag eltünteti a folyamat azonosítóját az összes állapotból, ahol megjelenik. Így ha volt hozzá regisztrált név, azt törli, a futó folyamatok halmazából is kiveszi a folyamatazonosítóját, és a \textit{terminatedProcess} állapotát hamisra állítja. Ez az állapot jelzi az összes folyamatnál, hogy terminált-e. Ez egy redundáns információ, mivel ha a \textit{processIds} nem tartalmazza a folyamatazonosítót, ugyanazt jelenti.

Ha a folyamat természetes módon terminál, és tartozik hozzákapcsolt folyamat, akkor annak a viselkedése teljes mértékben megegyezik az \textit{exit(normal)} hívással. Ha a folyamat futásidejű hibát okoz, akkor a terminálása megegyezik a \textit{exit(Reason)} hívással, ahol a \textit{Reason} a futásidejű hiba. Ezekben az esetekben a \textit{k} cellához tartozó átmenetek ezeket a függvényeket teszik bele a számítási folyamba.

\input{\RULESFOLDER/43EXIT1WITHLINK}

A fent látható szabály az egy paraméteres \textit{exit} függvény szemantikadefiníciójához tartozó szabályok egyike. Abban az esetben, ha össze van kapcsolva folyamatokkal, akkor kiolvassa ezek azonosítóját a \textit{linkedProcesses} állapotból. A \textit{k} cella átmenetében látható egy új \textit{Exp} fajta, a három paraméteres \textit{\$exit}, ami egy környezetet ad a folyamat szignál küldéseihez. Első paramétere a folyamat, ami a szignált küldi, második paramétere azon folyamatazonosítók halmaza, mellyel az első paraméterben lévő folyamat össze van kapcsolva, utolsó paramétere pedig a terminálást kiváltó ok. A \textit{\$exit} környezet azért lett létrehozva, hogy egységesen lehessen kezelni az egy és a két paraméteres \textit{exit} függvényeket. Láthatjuk hogy az átmenet itt is eliminálja a folyamatazonosítót a lehetséges állapotokból, a \textit{processesDuringExit} állapotot kivéve. Ez az állapot azért jött létre, mivel egy lépésben nem kivitelezhető az összes szignál küldés és a folyamat terminálása. Ezzel el tudjuk kerülni, hogy egy éppen terminálás alatt lévő folyamat szignál küldéseit összezavarja.

Érdemes megfigyelni a \textit{k} cella átmenetét. A \textit{\$exit} után egy \textit{\$terminated} kerül a számítási folyamba. Ennek oka, hogy mindenféle feltétel nélkül akarjuk megállítani a további kiértékelést. Miután a \textit{\$exit} környezet eliminálása megtörténik, a maradék kód még ottmarad a \textit{k} cellában. Ahhoz hogy ne értékelje tovább, minden egyes szabálynak tartalmaznia kellene egy olyan feltételt, ami azt állítja, hogy a \textit{processIds} állapotban benne van a folyamat azonosítója. Ezzel a trükkel viszont nem kell a többi szabályt bővíteni, hiszen a \textit{\$terminated} miatt nem fognak illeszkedni a konfigurációra.

A két paraméterű \textit{exit} függvénynél már bonyolultabb szabályok jelennek meg, mivel ott még azt is kell figyelni, hogy a \textit{trap\_exit} flag értéke mire van beállítva. Ezenkívül küldheti saját magának is az üzenetet. Itt a szabályok halmaza két nagy részre osztható. Az egyik mikor kell exit szignált küldenie, a másik pedig mikor üzenetet kell küldeni a folyamatnak.

\input{\RULESFOLDER/43EXIT2LINKNOTRAP}

Ebben a szabályban az egyik folyamat terminál egy másikat. Ha nem a \textit{normal} okkal, és a folyamat \textit{trap\_exit} flagje hamis vagy az ok a \textit{kill} atom, akkor a folyamatot terminálja, és mivel van hozzákapcsolva folyamat, a \textit{k} cellában az átmenet szintén a \textit{\$exit} környezetet hozza be, és elkezdődik az exit szignál küldése. A szemantikadefiníció többi szabálya is hasonló. Mind a feltételben különbözőek, és attól függően kezelik a folyamat terminálását. Érdekes szabály még az alábbi is.

\input{\RULESFOLDER/43EXIT2TRAPEXITWAITMSG}

Ez azt az esetet írja le, mikor egy folyamat éppen \textit{receive} kiértékelése közben van, üzenetre vár, és a \textit{trap\_exit} flaghez pedig a \textit{true} atom van hozzárendelve. Ekkor nem csak az üzenetet kell elküldeni, hanem azért is felelős, hogy a folyamat elkezdje újra elölről átnézni a postafiókját. Emiatt a folyamat \textit{k} cellájában a \textit{\$wait\_msg}-t eliminálja. Ha újra a folyamatra esik a kiértékelés, akkor elkezdi ellenőrizni a postafiókját. Természetesen ha a termináló ok a \textit{kill} atom, akkor ez a szabály nem alkalmazható.

Még sok szabály van, amit itt külön nem részletezek. Ilyenek például a már említett esetek, mint mikor a saját folyamatazonosítóját adja meg paraméterként, vagy a terminálás oka \textit{normal} atom, vagy az adott folyamatazonosító nem identifikál semmilyen folyamat. Összesen tíz darab szabály tartozik a két paraméterű \textit{exit} függvény szemantikadefiníciójához. Már csak egy kis részlet maradt hátra a \textit{\$exit}-hez tartozó szabályok, melyek a szignál küldését bonyolítják le.

Ezek a szabályok gyakorlatilag egy az egyben megegyeznek a két paraméteres \textit{exit} függvénnyel. A második paraméterben lévő halmazt járják végig, és minden egyes folyamatot módosítják feltételektől függően, mint például a termináló ok, és a \textit{trap\_exit} flag. Mondhatni egy rekurzív függvényt szimulál, melynek a kilépési pontja az alábbi szabály.

\input{\RULESFOLDER/43DOLLAREXITEXIT}

Ha az összes hozzákapcsolt folyamatnak elküldte az exit szignált, vagyis a második aktuális paramétere üres halmaz, akkor a folyamat végleg terminálhat. Előzőleg már a \textit{processIds} állapotból ki lett véve a folyamatazonosítója, illetve minden állapotból kikerült még a terminálás bekövetkeztekor, vagy az \textit{exit} hívásakor. Tehát már csak a \textit{processesDuringExit} állapotból kell kivenni a folyamatazonosítóját, ezzel jelezve hogy befejezte az exit szignálok küldését.

\paragraph{}
Összesen 21 szabály kapcsolódik a terminálással kapcsolatos szemantikához. A konkurens résznyelvet leíró szemantikadefiníció végül 61 szabályt és 9 szemantikus függvényt tartalmaz.

\subsection{Tesztelés}

Egy bonyolult és összetett szemantikadefiníciót ismerhettünk meg az előző fejezetben. A függvények sokszor egymástól függnek, ilyen például a folyamatok közötti kapcsolatok és a terminálás. A definíció írása alatt könnyedén lehetett úgy bővíteni a szabályhalmazt és az állapotteret, hogy a már megírt szabályok nem adták vissza megfelelően a manuálban leírtakat. Emiatt a definíció írásának jól meghatározott ciklusai voltak.

A ciklus első lépése a manuál értelmezése volt, a nem egyértelmű részek megvitatása, ezekre válasz keresése. Erlanghoz egy széles körben elterjedt implementáció létezik \cite{ErlRefDown}, amely jó referenciát adott kérdéses esetekben. Második lépésként az összegyűjtött adatok alapján apró példakódokat írni, mellyel a függvény egy-egy specifikus működését lehetett ellenőrizni. Harmadik lépés pedig maga a szabályhalmaz megírása, amit az előző fejezetben láthattunk is. Abban az esetben, ha a megírt részekhez tartozó tesztek megbuktak, negyedik lépésként össze kellett hangolni a szabályokat, esetleg a teszteket módosítani, hogy újra zöld legyen az út.

A második lépésben segítséget nyújtott a $\mathbb{K}$ keretrendszer tesztelő egysége. Ha futtatunk egy programot a \textit{krun} paranccsal, akkor a végkonfiguráció lesz az eredmény, ha terminált a program. Ebből lehet mintaillesztéssel információt nyerni.

\lstinputlisting[language=erlang]{\EXAMPLESFOLDER/count.erl}

Legegyszerűbben egy példán keresztül lehet bemutatni a működését. Vegyük a fenti programot. A \textit{count\_to\_ten} függvénnyel a rekurzív hívás szemantikáját lehet tesztelni. A visszatérési értéke mindig a tízes szám lesz, abban az esetben ha a szemantikadefiníciók helyes. Így a végkonfiguráció \textit{k} cellájában a tízes értéknek kell szerepelnie. Helyes működés esetén az alábbi végkonfigurációt kapjuk:

\lstinputlisting[language=XML]{\EXAMPLESFOLDER/vegkonfig.xml}

Ez egy nagyon jó példa arra, hogy egy ilyen kis program esetén is ugyanazzal a hatalmas állapottérrel dolgozunk, mint egy összetettebb, több folyamatot tartalmazó programnál. Leegyszerűsíthetjük, kiemelhetjük mintaillesztéssel a számunkra hasznos részt a \textit{--pattern} kapcsolóval és egy utánalévő mintával. Ebben az esetben a \textit{k} cella végállapotára vagyunk kíváncsiak, és csakis abban az esetben, ha az \textit{Value} fajtát tartalmaz. Ekkor az alábbi mintát kell megadni:

\lstinputlisting[language=XML]{\EXAMPLESFOLDER/pattern.xml}

A minta a \textit{k} cellára illeszkedik. Ha több folyamat lenne a végkonfigurációban, akkor az összes \textit{k} cellára illeszkedne, ami csak egy \textit{Value} fajtát tartalmaz, és az összes eredményt visszaadná kimenetként. Lefuttatva a programot ezzel a mintával eredményként az alábbit kapjuk:

\lstinputlisting[language=XML]{\EXAMPLESFOLDER/search_result.txt}

Ez már könnyebben olvasható, mint a fenti teljes végkonfiguráció. Ha ezt a kimenetet elmentjük a programot tartalmazó fájl nevével a végére illesztve a \textit{.out} kiterjesztést, akkor egyszerűen automatizálhatjuk a tesztjeinket. Ezt a \textit{ktest} paranccsal és egy hozzátartozó \textit{config.xml} fájllal tehetjük meg, ahol megadhatjuk, hogy az egyes programokra milyen mintát illesszen, és az eredményt összehasonlítja a \textit{.out} fájlban lévővel. Ennél természetesen sokkal bonyolultabb mintákat is lehet konstruálni, és tesztelés során kellett is.

Azonban a rendszernek vannak hiányosságai. Például, ha egy map tartalmára vagyok kíváncsi, akkor ott számít a sorrend. Sokszor előfordult, hogy \textit{kompile} parancsot használva ugyanazt az eredményt kaptam meg, de a map sorrendje megváltozott. Ezen felül az idő ellenőrzése is sokszor bajos volt, mivel volt hogy néha kevesebb, néha kicsit több volt, főleg ha a szabályhalmaz bővítve lett. Mindezek ellenére nagyon hasznos eszköznek bizonyult munkám során.

A konkurens rész összesen 38 tesztet tartalmaz. Minden teszt esetén a mintával az éppen számunkra érdekes információt nyerjük ki a végkonfigurációból, amiből kiderülhet, hogy az adott kódrészlet helyesen futott-e le. Felmerülhet a kérdés, hogy ezek a tesztek ténylegesen a helyes működést ellenőrzik? Minden egyes teszt írásakor a manuálra és az implementációra építettem, ahogy a szemantikadefiniálásakor is.

% Eddig ellenorizve