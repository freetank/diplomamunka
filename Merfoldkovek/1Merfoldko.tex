% Preamble
% ---
\documentclass[]{article}
% \documentclass[11pt,a4paper]{article}

% Packages
% ---
\usepackage[utf8]{inputenc}
\usepackage[magyar]{babel}
\usepackage[T1]{fontenc}

\usepackage{xcolor}
\usepackage{listings}

\begin{document}

\section*{1. Mérföldkő}
Az első mérföldkőig az Erlang nyelv párhuzamos programozást támogató résznyelvének K-ban definiált futtatható formális szemantikájának elkészítése volt a cél. Emiatt a már meglévő nyelv definíció bővült egy CONCURRENT-PARSING és egy CONCURRENT modullal, és ennek megfelelően a konfiguráció is bővült. Továbbá 38 darab teszt segítségével a munka során folyamatosan tudtam ellenőrizni szemantika definícióm helyességét.

\subsection*{A konfiguráció bővülése}
A jelenlegi konfiguráció alább látható:

\lstset{language=XML}
\begin{lstlisting}
<T color="yellow">
  <processes color="orange">
    <process multiplicity="*" color="magenta">
      <k color="green"> $PGM:Pgm </k>
      <env color="LightSkyBlue"> .Map </env>
      <pid> <0.0.0> </pid>
      <mailbox> .List </mailbox>
      <processFlag> trap_exit |-> false </processFlag>
      <terminatedProcess> false </terminatedProcess>
    </process>
  </processes>
  <processIds> SetItem(<0.0.0>) </processIds>
  <processesCheckMails> .Set </processesCheckMails>
  <idleProcesses> .Map </idleProcesses>
  <processesDuringExit> .Set </processesDuringExit>
  <registeredProcesses> .Map </registeredProcesses>
  <linkedProcesses> .Map </linkedProcesses>
  <time> 0 </time>
  <defs color="blue"> .Map </defs>
</T>
\end{lstlisting}

A processes tartalmazza, az összes futó folyamat konfigurációját. Itt négy típusértékhalmazzal bővült az állapot tér, ami a párhuzamos résznyelvhez kötődik.

\begin{itemize}
\item pid: A folyamat azonosítóját tartalmazza. A fő folyamat azonosítója mindig <0.0.0> lesz. Szükséges itt beállítani, mivel nem lehet úgy véletlenszerűen generáltatni, hogy azt a processIds állapot is tudja tartalmazni.
\item mailbox: Egy lista, amely folyamatnak küldött üzeneteket tartalmazza. Mivel listában van tárolva a sorrendiség megmarad.
\item processFlag: A process\_flag függvény által beállítható flageket tartalmazza. Csak a trap\_exit flaggel foglalkoztam a szemantika definíálás során.
\item terminatedProcess: Egy logikai értéket tartalmaz, ami jelzi, hogy a folyamat terminált-e vagy sem.
\end{itemize}

A többi állapot közös az összes folyamatra nézve.

\begin{itemize}
\item processIds: Az összes futó folyamat azonosítója. Ennek segítségével a jövőben eliminálható a terminatedProcess típusértékhalmaz.
\item processesCheckMails: Azon folyamatok azonosítója, melyek éppen receive utasításnál vannak, és éppen vizsgálják a mailboxukban lévő üzeneteket.
\item idleProcesses: Azok a folyamatok azonosítója, melyek receibe utasításnál vannak, és már ellenőrizték az üzeneteiket. Emiatt újabb üzenetekre várnak, illetve ha rendelkeznek after résszel, akkor az ott meghatározott idő letelésére is figyelnek.
\item processesDuringExit: Azon folyamatok azonosítója, melyek exit signált kaptak, vagy elérték a program végét, és az összelinkelt folyamataiknak jelzik, hogy termináltak.
\item registeredProcesses: Névvel regisztrált folyamatok.
\item linkedProcesses: Az egymással link utasítással összekapcsolt folyamatok.
\item time: A program elindulásától számított eltelt időt reprezentálja. Mivel a K keretrendszertől nem lehet az adott időt lekérdezni, emiatt minden egyes utasítás egységesen 10-zel növeli az értéket, ami milliszekundumban értendő.
\end{itemize}


\subsection*{Utasítások}
Nem a párhuzamos programozást támogató résznyelvhez tartozik, de a mintaillesztést definícióján is finomítottam. Eddig csak változókhoz lehetett értéket rendelni, most már a pattern matching is működik.

\subsubsection*{Folyamat létrehozása}
Új folyamatot a spawn utasítással tudunk létrehozni. Az utasítással az állapot tér processes részébe új process kerül, generáltatva magának egy egyedi folyamat azonosítót.

\subsubsection*{Regisztrált folyamatok}
A register utasítással tudunk nevet adni egy folyamatnak. Ekkor az állapottér registeredProcesses map-be teszi a megadott név és a folyamat azonosítójából készített párt. Ha már egy névhez van regisztrálva név, vagy az adott névhez már regisztráltak nevet, akkor bad\_arg hibával tér vissza az utasítás. Ezenfelül ugyan ezt a működést érjük el, ha a megadott név undefined, vagy egy nem meglévő folyamatot akarunk regisztrálni.

A registered és a whereis utasítások ebből a registeredProcesses állapotból tudják lekérni a számukra szükséges adatokat. Az unregiszter pedig törli ebből állapotból a névhez tartozó értéket.






\subsection*{Ktest}
A teszteléshez a K keretrendszerhez tartozó ktest nevű programot használom. A kompile pattern kapcsolójával meg lehet adni hogy a konfigurációnak mely részére vagyunk kiváncsiak. Ez jelentheti a végállapotot is, vagy futás közbeni köztes konfigurációt is. A ktest program bemenetként egy config.xml fájlt vár, ahol megadhatjuk hogy mely teszteket futtassa le; külön teszt esetenként megadható, hogy milyen patterneket keressen a konfigurációban; hogy szükséges-e a fordítás tesztelés előtt; illetve pdf-t is generálhatunk vele (jelenleg ez nem működik). A tesztek futtatása párhuzamosan zajlik. A tesztek kimenetét összehasonlítja a <teszt-név>.out fájlban lévő eredménnyel. Jelenleg minden teszthez írtam .out filet, definiáltam patternt és az eredmény két config.xml fájl lett. Egy a szekvenciális tesztekhez, egy pedig a konkurensekhez.

\subsection*{Irodalmak}
Az erlang nyelvvel való ismerkedés Madridban az Applied Declarative Programming tárgy keretében zajlott, ahol gyakorlatilag többet is vettünk, mint ami ehhez a diplomamunkához szükséges. Illetve nagy segítséget nyújtott még a learnyousomeerlang.com oldal is, ahonnan tesztekhez még jó példákat is tudtam venni. A K keretrendszer használatához a release-ben lévő példák mutattak utat. A 4.0-ra való áttéréshez, a ktest használatához a github.com/kframework/ k/wiki/Manual-(to-be-processed) oldal adott sok hasznos tanácsot. A szemantikával kapcsolatos elméleti anyag esetében pedig a Formális szemantika tárgy diáira támaszkodom.

\end{document}
